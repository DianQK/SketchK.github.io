<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[A Guide Of Making Your Personal Blog - Part 7]]></title>
      <url>%2F2017%2F03%2F24%2FA-Guide-Of-Making-Your-Personal-Blog-Part-7%2F</url>
      <content type="text"><![CDATA[终于把教程写完了，现在让我总结一下！ Afterword要想搭建一个优雅且功能强大的博客远不止我说的这些内容，要想深入的话其实还有很多可以讨论的内容。 不过我打算就此停止关于如何搭建个人博客的话题了！ 在这里要感谢很多这段时间给予我帮助的朋友 - 恩生，樉爷，宇杰，还有在 GitHub 上的好朋友 @farseerfc 和 @PoiScript 好了， A Guide Of Making Your Personal Blog 系列就此完结啦！ 希望大家也能早日搭建出属于自己的博客！ Reference Material 域名购买推荐使用 GoDaddy : http://www.godaddy.com/ GoDaddy 的优惠码： http://www.dute.me/ GitHub 的官网： https://github.com/ GitHub Pages 的官网: https://pages.github.com/ Travis CI 的官网：https://travis-ci.org/ 域名解析的服务商推荐使用 DNSPods: https://www.dnspod.cn/ 博客框架推荐使用 hexo 框架： https://hexo.io/zh-cn/ 博客主题推荐使用 NexT 主题： http://theme-next.iissnan.com/ Git 的官网： https://git-scm.com/ Node.js 的官网： https://nodejs.org/zh-cn/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[A Guide Of Making Your Personal Blog - Part 6]]></title>
      <url>%2F2017%2F03%2F24%2FA-Guide-Of-Making-Your-Personal-Blog-Part-6%2F</url>
      <content type="text"><![CDATA[这一节讨论的内容是博客的自动部署问题，应该算是一个比较高级的话题了，不过实现了这一步，我们就可以”自由”的发布文章啦！ 自动部署使用 Hexo 写博客是一件十分幸福的事，但让很不爽的是每次写完 markdown 文档后都要手动生成静态文件并重新部署到 Github 上，反复的操作不禁让人感到厌烦。 虽然上面的问题可以用脚本来解决，但这并不能解决所有的问题，假如我们换了一台电脑就需要重新安装 Git, Node.js，Hexo等等，这其实也挺麻烦的。 那么有什么好的解决方案呢？ Travis CI在说 Travis CI 之前，我们先说说持续集成，持续交付和持续部署的概念。 持续集成（Continuous integration）就是频繁地（一天多次）将代码集成到主干。它的目的就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。 持续交付（Continuous delivery）在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的 “类生产环境”（production-like environments）中。比如，我们完成单元测试后，可以把代码部署到连接数据库的测试环境中。如果代码没有问题，可以继续手动部署到生产环境中。 持续部署（continuous deployment）是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。持续部署的前提是能自动化完成测试、构建、部署等步骤。 说完这三个概念，我们来说说 Travis CI，你可以把它理解为一种服务。总之它的主要任务就是处理持续集成，持续交付和持续部署的相关事宜，而且很重要的一点就是它对 GitHub 的支持十分友好，加上它的免费策略，我们没有理由不去选择它，当然你也完全可以用 Jenkins 等类似的服务。 好了，Travis CI 的介绍到此结束了，我们下面就来说说如何利用 Travis CI 来实现自动部署吧。 解决方案Travis CI 的工作原理是在每次提交 commit 到 Github 后，它会自动检测到我们的提交，此时 Travis CI 会生成一个虚拟机，它会根据我们写好的指令进行相关的操作。 那么我们到底要怎么干呢？我们来罗列下相应的步骤 我们在 Github 的博客仓库里新建一个 blog-source 分支，然后把博客的源码托管到这个分支 每当我们在本地写好了博文之后，把修改 push 到该分支 Travis CI 上可以对这个项目的 blog-source 分支设置 webhook，每当检测到 push 的时候就去仓库 clone 源代码 Travis CI 执行构建脚本 Travis CI 把构建结果通过 push 部署到 master 分支的仓库里 如果看文字比较晕，可以看看我画的这张图。 我想结合着文字和图片，你已经明白我们要干什么了，所以如果我们实现了这个方案，在这样的自动化流程下，我们唯一需要做的事情就是 push 文章到 blog-source 分支，其他的事情交给 Travis CI 了。 是不是突然觉得世界都美好了呢，好了，开始干活吧！ 这次的实践需要掌握一些基本的 Git 命令，如果对 Git 命令不熟悉，建议看看廖雪峰的 Git 教程 创建 blog-source 分支如果你对 Git 的相关操作比较熟悉，这一步应该相当简单，不过为了便于大家的理解和保持文章的一致性，我们还是把这个步骤中的相关操作写下来。 1234567$ cd /path/of/your/blog/source/$ git init$ git checkout -b blog-source$ git add .$ git commit -m "XXX"$ git remote add origin git@github.com:XXX/XXX.github.io.git$ git push -u origin blog-source 简单的解释下吧： 第 1 行是利用 cd 命令跳到站点根目录下 第 2 行是在这个文件夹下利用 git init 命令初始化仓库 第 3 行是在当前仓库创建一个 blog-source 分支 第 4，5 行是在进行一次 commit 操作，用来保存当前的修改，XXX 是用于记录此次 commit 的信息 第 6 行是将本地仓库与 github 中的仓库关联到一起，这里的 XXX 是你的 GitHub ID 第 7 行是将本地的分支推送到远端的 blog-source 分支中 最后的效果就是，当你点击 branch 按钮的时候，你会发现多了一个 blog-source 分支。 不过在结束这一步之前，让我们来看一下 blog-source 分支中的 themes 文件夹，你会发现 next 文件夹是一个空文件夹，里面并没有任何文件，这是为什么呢？ 原因很简单，就是之前我们使用了 git clone https://github.com/iissnan/hexo-theme-next themes/next 的方式引入第三方主题，这个命令会在本地电脑的 next 文件夹下生成 .git 文件夹，这也就意味着 next 文件夹也使用了 Git 来进行版本管理，自然而然的这个 next 文件夹就不会纳入到站点根目录的版本管理中。 所以把 next 文件夹下的 .git 文件删除，重新进行一次提交。 配置 Travis CI开启仓库的 Travis CI 功能登录 Travis CI 的网站，使用 GitHub 账户登录，成功登录后点击右边的头像，会弹出来个下拉菜单，点击 Accounts 按钮 这时候你会在界面上看到你在 GitHub 里的所有仓库，我们只需要打开存有博客资源的仓库即可。 这时候点击 SketchK/SketchK.github.io 会跳入这个项目的详情页，点击右上角的 More options 里的 Setting 按钮，就会进入下面的页面，我们可以打开 build only if .travvis.yml is present 和 build branch updates， 至于 build pull request updates 可以根据自己的实际情况来选择是否开启。 我完全不知道这四个选项代表啥意思啊 ？ 好吧，如果你不愿意看 Travis CI 的文档话，我简单说一下这四个选项的意思 Build only if .travis.yml is present：是否在 .travis.yml 文件存在的情况下开始才构建； Build pushes：是否在推送完这个分支后开始构建。 Limit concurrent jobs: 是否限制同时执行的操作数量 Build pull request updates：是否在 PR 合入后执行构建 到这一步， 我们已经开启了要构建的仓库，但此时 Travis CI 还没法帮助我们自动构建并部署。 push 权限我们在使用 Github 的时候，首先需要在 Github 上配置公钥，这是最基础的。那么，存在我们本地的私钥就是你的个人身份标示，如果你的项目 git 地址配置的是 git@github.com:username/projectname.git（相对的还有 https://github.com/username/projectname.git），当你对仓库进行一些操作（比如 push 等），则需要私钥进行身份验证了（这是自动验证的，如果是使用 https 的配置，则需要提供用户名和密码）。 我们在 Travis CI 上自动部署代码，就牵扯到了 push 操作，那么就需要提供私钥了。所以我们该怎么解决这个问题呢？ 你会说把我们本地的私钥上传到 blog-source 里就 ok 啦，当然这么做理论上是没有任何错误的。 但你得知道，我们在 GitHub 的仓库可是公开的，也就是说谁都可以看到你的私钥了，这样的话，原本用来保密的私钥就失去了意义，更可怕的是，如果被一些居心不良的人盯上你的私钥，你可能就会遇上麻烦了。 那么我们该怎么办呢？ 解决方案目前网上主流的做法都是基于 Travis 提供了加密文件的支持，但具体的实现会有一些不同，什么意思呢？ 一种方式就是我们可以在本地对文件（这里指私钥，比如 id_rsa 文件）进行加密，然后把加密过后的文件放在项目里，那么别人就无法获取里面的真实内容。然后我们在让 Travis 执行脚本的时候，在读取加密文件之前对文件进行解密（使用的解密密码需要提前在 Travis 上配置好），这样就可以达到不将文件内容暴露，并且让 Travis 获取到真实内容的目的了，大概流程如下： 第二种方式是利用了 GitHub 的 Personal Access Token，由于这个 Token 与 帐号密码 以及 SSH Keys 同样具有 Github 写入能力，因此只要使用 Travis CI 提供的加密工具来加密这个 Token 即可。 它的流程如下 虽然这两种方式都可以解决问题，但实际操作起来都很麻烦，难道就没有什么别的方式了么 ？ 好在 Travis CI 提供了一个 Environment Variables 这个功能，那么我们完全可以使用一种简单的方式来实现我们的目的。 在 GitHub 的 Personal Access Token 中创建 Token 将 Token 的 value 值添加到 Travis CI 的 Environment Variables 对远程仓库的 push 操作使用如下方式来完成。 1git push -f -q https://&lt;username&gt;:$GITHUB_TOKEN@github.com/&lt;username&gt;/&lt;repo&gt; 是不是看起来，还不错，下面就让我们开干吧！ 这种 push 方法出自另一家 CI 服务公司 AppVeyor 的文档，详情请点击这里。 生成 Personal Access Token登录 GitHub 的 Setting 页面，点击右边侧边栏的 Personal access tokens 后，进入下图所示的界面，此时点击右上角的 Generate new token 按钮 点击完以后会要求你重新输入一遍 GitHub 的密码，然后就会进入下面的界面，这个界面大概是在说我们应该赋予这个 token 的权限有哪些，根据目前的要求，我们只需要把 repo 选项框里的前两个权限勾上即可，如果你的博客有一些特殊的需求，就根据自己的情况选择吧。 勾选完后，点击最底下的 Generate Token 按钮，你就会得到一个 token，唯一需要注意的是 token 的值只会显示一次，所以记得把这个值保存一下。 在 Travis CI 上设置 Environment Variables现在让我们回到 Travis CI 的界面中，把 Token 的 Name 和 Token 的 Valve 填到 Environment Variables 中，然后再点击下 Add 按钮。 现在 Travis CI 通过我们的设置已经与 Personal Access Token 产生了关联。 神奇的 .travis.yml 文件在 Travis CI 的官方文档里有这么一段话: Travis CI provides a default build environment and a default set of steps for each programming language. You can customize any step in this process in .travis.yml. Travis CI uses .travis.yml file in the root of your repository to learn about your project and how you want your builds to be executed. .travis.yml can be very minimalistic or have a lot of customization in it. 它的大体意思是说 Travis CI 为不同的编程语言提供了不同的编程环境，我们可以用一个叫 .travis.yml 的文件定义 Travis CI 需要执行的任务，同时我们需要把这个文件保存到站点根目录中。 既然 .travis.yml 是用来控制 Travis CI 的，那么我们应该如何编写这个文件呢？ 在编写这个文件之前，我们不妨先说说 Travis CI 的构建周期，如果你不太理解构建周期的意思，我们来打个比方吧。比如我们办事的时候总会有个第一步，第二步，直到最后一步，我们可以把这个过程理解为构建周期，而第一步，第二步之类的概念理解为这个构建周期的时间节点。 那么 Travis CI 的构建周期主要分两步： install 用于安装构建所需要的一些依赖 script 运行构建脚本 而 Travis CI 提供了下面 12 种标签来描述一次构建周期的各个时间节点： Install apt addons: 在这个节点中，可以使用 apt 包管理器来安装一些依赖包 Install cache components: 这个节点的作用是缓存一些不常改变的东西，可以加快编译速度 before_install 这个节点是指在 install 步骤之前的动作 install: 这个节点的作用是用来安装依赖或者工具 before_script: 这个节点是指在 script 执行之前的动作 script: 这个节点下的动作是由 bash 来解析的，这里放构建的主要步骤 before_cache: 这个节点主要用于清除 cache after_success or after_failure: 这个节点是指在构建成功或者构建失败后的动作 before_deploy: 这个节点是指在部署之前的动作 deploy: 这个节点是执行相应的部署操作 after_deploy: 这个节点是指部署之后的动作 after_script: 这个节点就是在 script 执行之后的动作 看了这么多的标签是不是有点懵，其实在实际的使用过程中，我们并不会用那么多的标签。 说的有点多了，直接把 .travis.yml 的代码放上来吧。 1234567891011121314151617181920212223242526language: node_jsnode_js: stablebranches: only: - blog-source - blog-themeinstall:- npm installbefore_script:- git config --global user.name "SketchK"- git config --global user.email "zhangsiqi1988@gmail.com"- git config --global push.default simplescript:- git clone --branch master https://github.com/sketchk/sketchk.github.io.git .deploy/sketchk.github.io- git clone --branch blog-theme https://github.com/SketchK/SketchK.github.io.git themes/next- hexo generate- cp -R public/* .deploy/sketchk.github.io- cd .deploy/sketchk.github.io- git add .- git commit -m "Travic CI Auto Build"- git push --quiet https://SketchK:$&#123;TraviS CI - Hexo&#125;@github.com/SketchK/SketchK.github.io.git 现在我们对这个文件分段说明下： install 标签之前的操作install 标签之前我们填写了 language, node_js, cache 以及 branches 标签， language 和 node_js 分别告诉 Travis CI 我们需要使用 node.js，它的版本是 stable 的。 branch 部分的代码是告诉 Travis CI 只监控 blog-source 分支的变化，只有这个分支产生变化了才会执行下面的操作。或许你会好奇 blog-source 分支具体产生何种变化才会开始构建？其实我们在前面已经设定过了，如果忘了，请仔细看看 开启仓库的 Travis CI 功能 一节的内容。 install 标签中的操作你肯定会好奇 Travis CI 是如何生成静态网页的，因为我们好像似乎没有告诉它应该去安装 Hexo 和其他相应的 Hexo 插件，只是在 .travis.yml 中输入了一句 npm install 的命令。 这时候我们需要看看几个没说过东西，下图是我们站点根目录的截图： 第一个就是 package.json, 打开它会发现该文件指定了我们所需要的 Hexo 和相应插件，而它是怎么知道的呢？其实这个文件是我们在本地配置 Hexo 及其相关插件时自动生成的，所以通过这个文件，Travis CI 在 执行 npm install 的时候就知道应该去下载何种软件，保证我们在执行 hexo g 的时候不会出错。 第二个就是 node_modules，Travis CI 通过 package.json 文件的内容去下载 Hexo 和相应插件，但下载完的东西需要放到哪里呢？node_modules 就是用来解决这个问题的。不过我们在 blog-source 分支中并没有看到这个文件夹，一方面是 .gitignore 里标明了排除这个文件夹，另一方面就是我们把 node_modules 文件夹里的内容 push 到 blog-source 上是没有意义的, 安装 Hexo 的工作可不是简单的把 node_modules 文件上传到 Travis CI 上就完事的。 before_script 标签中的操作在执行具体的工作前，我们需要告诉 Travis CI 执行 Git 命令的操作者是谁，否则你的操作会出问题哦！另外记得加 --global 参数 script 标签中的操作这一段的代码与我们之前的 deploy.sh 文件的代码十分相似。不过需要需要注意的是我们这次 push 的地址是与之前的方式不一样的，它的通用样式如下： 1git push https://&lt;username&gt;:$GITHUB_TOKEN@github.com/&lt;username&gt;/&lt;repo&gt; 不过就像我的示例代码中，在 push 后面一定要加 --quiet 参数，因为不加这个参数的时候会把 $GITHUB_TOKEN 的具体值显示出来，这样我们之前的加密工作就白费了 几个需要注意的地方 如果你的 Travis CI 没有提示任何错误，但打开网站发现一片空白，那么八成就是你的 themes 文件夹出现了问题，可以仔细排查下这一块的代码和逻辑。 - git config --global push.default simple 是 Git 2.0 带来的改变，如果我们不写这句话，在 Travis CI 里会看到一些 warning ，不过没有它似乎也不会有什么问题，只是后面的参数为 simple 的时候，执行 git push 且 没有指定分支时，只有当前分支会被 push 到对应的远程仓库。 如果你的 Token 中有一些特殊操作符，那么在进行 push 操作时，你可以像我的示例代码中一样使用 { } 的方式把 Token 包起来，如果没有空格直接按照通用样式就可以了。 至于为什么把 push 操作放到 script 中，这是因为 Travis CI 判断构建项目的成功与失败主要在 script 中完成，如果我们把 push 操作放到 after_script 或者 after_success 中，即使 push 失败了，Travis CI 也会显示此次的构建成功。所以为了能够保证自动部署的成功，我把这个步骤放到了 script 中。 测试一下做完这些工作后，我们把修改好的文件 push 到 blog-source 分支吧。然后再回到 Travis CI 的控制台看看发生了什么？ 果不其然，Travis CI 已经检测到变化并进行构建部署了！ 点击下面的 Job Log 可以查看整个构建过程。 如果构建失败的话，也不用害怕，Job Log 里会有详细的信息。这些信息足够你去解决它们了。 现在，你终于完成了个人博客的自动部署工作了！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[A Guide Of Making Your Personal Blog - Part 5]]></title>
      <url>%2F2017%2F03%2F24%2FA-Guide-Of-Making-Your-Personal-Blog-Part-5%2F</url>
      <content type="text"><![CDATA[估计你早就对当前这个博客的样式感到不满了，所以这一章我们来讨论下 Hexo 主题并亲手配置一下它吧！ 博客主题使用 Hexo 框架可以使用不同样式的主题，它们被放在了这里，你可以随意挑选一个自己喜欢的。 估计这时候你已经选出了自己喜欢的主题，但你很快就会发现大部分主题的说明文档并不是那么友好，所以我们应该怎么办呢？ 幸运的是 NexT 主题拥有一套完整的说明文档，所以今天就拿它举例了。 _config.yml 文件在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件。 下载主题在终端窗口下，定位到站点根目录下。输入以下代码： 12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题与所有 Hexo 主题启用的模式一样。 当完成 git cloen 后，打开站点配置文件， 找到 theme 字段，并将其值更改为 next。 1theme: next 到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用 hexo clean 来清除 Hexo 的缓存。 验证一下启动 Hexo 本地站点，并开启调试模式（即加上 --debug），整个命令是 hexo s --debug。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出： 1INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 一些说明文档上没有说的事儿估计你马上就会发现上面一节的内容和 NexT 官网上的内容一模一样，没错，确实是从官方文档上面 copy 过来的，因为官方文档已经把大多数问题都说清楚了，所以我就不把说明文档里的内容再重复一遍了，让我们说点文档里面没提到的吧。 创建 about 界面在终端输入 1hexo new page about 在主题的 _configy.yml 设置中将 menu 中 about 前面的注释去掉即可。 12345menu: home: / archives: /archives tags: /tags about: /about 需要注意的是，在 about 的页面中，title 是不会自动对齐的，如果想达到对齐的方式可以直接把 title 放到正文中，然后用 hexo 的居中对齐标签来实现该效果。 还有就是记得在这个 md 文件的 front-matter 里加入 comments: false 的语句，否则about 页面里面还会出现评论组件，如果你没有在博客系统里面添加过评论组件或者本意就想显示评论组件，这一条可以忽略。 博客 favicon 图标先说说什么是 favicon 图标，看到下图左边蓝色的 logo 了么，它就是 favicon 图标。 制作这个东西很简单，将你喜欢的图片放到 RealFaviconGenerator 网站中进行转换，然后把获得的 ico 文件放到 source 文件夹中 最后在主题配置文件 _config.yml 中的 favicon 字段里填写 ico 图片的地址 1favicon: /YourIcoPath 好了，重新部署一下你的网站就可以看到自己的 favicon 了！ 如果没有看到，请不要着急，等上一会再看看，如果还是不行的话，请查看一下图片的路径和文件的格式是否有误。 sitemap 设置和蜘蛛协议在开始之前，还是先说说 sitemap 是什么东西。 你可以把 sitemap 当做一个网站的说明书，它用于告诉搜索引擎这个网站里面有什么内容，以便用户在使用搜索引擎的时候，更容易找到这个网站的相关资源。 所以说做这件事的目的就是为了让他人能够更好的找到你博客里的内容，如果你并不希望他人找到的话，那么你完全可以忽略这节的内容。 下面我会具体演示一遍向 Google 添加 sitemap 的过程，走起！ 向 Google 证明你对自己博客的所有权，参考 NexT 文档中的 Google Webmaster tools 一节完成对博客的验证。 在站点根目录下安装插件 hexo-generator-sitemap 在站点配置文件 _config.yml 中加入以下字段 123sitemap: path: sitemap.xml template: ./sitemap_template.xml 重新生成博客文件，并确认 public 文件夹下是否多出一个 sitemap.xml 文件 在 Google 的 Search Console 里填写 sitemap 地址，看看是否检测成功 大概过几分钟，在 Google 的搜索栏里输入 site:YourDomain,例如我的就是site:sketchk.xyz, 如果能够像下图一样展示出你的网站，那么就说明你的网站已经被正确收录了。 弄完了 sitemap 的设置，我们来说说蜘蛛协议。 蜘蛛协议就是和蜘蛛之间的约定，哈哈，是不是很想死，不过这里的蜘蛛并不是真正意义上的蜘蛛，而是存在于网络中的网络爬虫，通过这个协议来规定这些网络爬虫到底能访问哪些资源，不能访问哪些资源。如果你对我说的东西还是感觉太不理解，我们来看看更官方的一种解释？ 网络爬虫是一种按照一定的规则，自动地抓取网络信息的程序或者脚本。它是搜索引擎中最重要的一项技术，通过网络爬虫，我们可以将互联网中数以百亿计的网页信息保存到本地，形成一个镜像文件，为整个搜索引擎提供数据支撑。 好了，知道蜘蛛协议是什么了，那我们赶紧操作起来吧！ 在站点根目录的 source 文件下新建 robots.txt 文件，添加以下文件内容 12345678910111213141516# hexo robots.txtUser-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /tags/Allow: /about/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: http://www.sketchk.xyz/sitemap.xml 在 Google Search Console 的 robots.txt 中测试你的协议是否被正确识别！ 好了，补充的内容就到这了，加上 Next 官网上的说明文档，我相信这个博客的功能已经基本够用了。 如果你想试试别的主题也未尝不可，生活嘛，就要多折腾才有意思！ 下一章我们来说说自动部署的话题吧！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[A Guide Of Making Your Personal Blog - Part 4]]></title>
      <url>%2F2017%2F03%2F24%2FA-Guide-Of-Making-Your-Personal-Blog-Part-4%2F</url>
      <content type="text"><![CDATA[这篇文章主要讨论了博客框架的话题。目前主流的博客框架有 Jeklly, Octopreess 和 Hexo。 选 Hexo 的因为它方便实用，至于我是怎么知道的，其实很简单，因为三种方式都试过。 博客框架我们在前面说过 GitHub Pages 服务允许我们访问已经写好的 HTML 等静态文件，所以我们对博客框架的需求就是产出静态文件。 幸运的是能完成这个需求的框架有很多，例如 GitHub Pages 官方推荐的 Jeklly, 也有基于 Jeklly 开发的 Octopreess, 不过我今天要说的是另外一个博客框架：Hexo。 所以废话少说，直接来看看 Hexo 吧。 安装 Hexo 的前提安装 Hexo 需要电脑里面安装 Node.js 和 Git。 Git 我们已经在前面安装过了，所以现在我们只需要安装 Node.js 了，具体怎么安装就不废话了，就列出官网链接吧：https://nodejs.org/en/ 如果你不知道自己是否安装了，在终端里面输入 $ node --version 来检查就好。 安装 Hexo所有必备的应用程序安装完成后，在终端下面输入以下命令来安装 Hexo。 1$ npm install -g hexo-cli 创建我们的博客吧！安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件，下面的代码中 &lt;folder&gt; 指的是文件夹的地址。 1234$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install新建完成后，指定文件夹的目录如下： 在之后的文章里，&lt;folder&gt; 文件夹会统一称为站点根目录 创建完毕后，你大概会看到这样一个目录结构。 实际生成的目录结构和 Hexo 官网给出的目录结果会有一些出入，不过估计是作者许久没有更新了，总之按照操作来就好。 预览我们的博客在站点根目录中，输入$ hexo server 后会出现如下的提示 所以让我们在浏览器里面输入一下 http://localhost:4000/ 吧，然后你看到了什么？ 以后我们在实际的使用过程中，每当修改完网站里的东西就可以通过这种方式来预览，而不是直接发布到网上。 生成静态网站好了,假设你已经修改好了网站，我们现在就要生成静态文件了，我们应该怎么做呢？ 我们只需要在站点根目录中输入 $ hexo generate 即可，执行完以后大概是下图这个样子。 此时，你会发现站点根目录里多了一个 public 文件夹，这个文件夹里的东西就是博客的静态文件，所以下一步，不用我说，你也应该知道我们要干什么了吧？ 部署我们的博客你是不是想起来我们要干什么了啊？ 如果忘记的话，也没事，我再重说一遍就好： 那就是把刚才生成的静态文件上传到 GitHub 仓库中。 如果你对 Git 的使用比较熟练，你完全可以通过 Git 把这些本地文件 push 到对应的仓库中。 如果你对 Git 并不熟悉，那该怎么办呢？ 还好 Hexo 给我们提供了另一种选择，通过它我们可以很方便的把静态文件部署到对应的仓库中，不过在使用这个功能前，我们需要做一点设置。 首先，打卡站点根目录中的 _config.yml 文件，找到 Deployment 字段，填写下面的内容， 1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 然后，在终端里安装一个用于帮助我们上传文件的扩展工具： 1$ npm install hexo-deployer-git --save 最后，在站点根目录中输入 $ hexo deploy 眼尖的朋友一定发现，我在终端里面实际输入的是 hexo d 而不是 hexo deploy, 这是因为 Hexo 对这些命令做了优化，大部分命令我们都可以使用简写的方式来执行，例如 hexo g 完全等同与 hexo generate，是不是对 Hexo 又产生了一点好感呢？ 现在在你的浏览器里面输入自己购买的域名吧！What !? 为什么是 404 页面。 其实道理很简单，打开你的 GitHub 仓库，发现有什么不对的地方么？ 你会发现库里面原有的 CNAME 文件没了，这也就是说 Settings 里面的 Custom Domain 没了，所以就会 404 喽。 是不是知道原理以后，出现这些问题也不会怕怕了，现在我们赶紧填写好 Custom Domain 吧，然后再次在浏览器里输入购买的域名！ 嘿嘿嘿！ 恭喜你！你的个人博客终于有个雏形了！ 改进一下每次都要填写 Custom Domain 参数？我想聪明的你马上会发现一个问题，似乎我们每次 hexo deploy 后，都要去修改 Custom Domain 这个参数，是不是感觉心好累 ? 解决这个问题并不难，我们只需要在 source 文件夹下面创建一个名为 CNAME 的文件，然后在这个文件里写上我们购买的域名就可以了。 为什么呢？因为 Hexo 的工作原理是将 source ，theme 等文件夹里的内容进行一顿处理，就变成 public 文件夹里的内容，如果我们在 source 里面放入了一个它无法处理的文件，Hexo 就会原封不动的把它拷贝到 public 文件夹中，这样也就解决了我们每次要修改 Custom Domain 的问题。 如果你不明白为什么加了一个 CNAME 文件就等于修改了 Custom Domain，请再阅读上一篇文章里 解释下在 GitHub 里的操作 一节的内容 hexo deploy 不好使了？有时候你会发现 hexo deploy 不好使了。我该怎么办？很简单，老老实实的用 Git 吧! 什么，还要我教一下 Git 的使用，我建议你还是看看廖雪峰老师的 git 教程。 如果你对每次敲击这些无聊且重复的 Git 代码感到厌烦，那我们来说说如何用一个脚本替我们完成这些工作吧! Talk is cheap , Show me the code! 123456789$ #!/bin/sh$ [ -d .deploy/&lt;Name&gt;.github.io ] &amp;&amp; rm -rf .deploy/&lt;Name&gt;.github.io$ git clone git://github.com/&lt;Name&gt;/&lt;Name&gt;.github.io.git .deploy/&lt;Name&gt;.github.io$ hexo generate$ cp -R public/* .deploy/&lt;Name&gt;.github.io $ cd .deploy/&lt;Name&gt;.github.io $ git add .$ git commit -m "update"$ git push origin master 需要说明的是，你要把 &lt;Name&gt; 换成你的 GitHub 账户名，然后把它保存为 deploy.sh 并放到你的站点根目录下。 有了它，我们只需要每次在终端里面输入 sh deploy.sh 即可以完成部署了，是不是很完美，让我们看一下它的实际运行效果。 不用纠结你终端里面展示的内容和我的不太一样，重要的是最后的那句 Everything up-to-date。 我说过凡事还是要搞明白，要不以后出问题都不知道该怎么办，所以各位还是耐着性子让我把这段 shell 脚本解释下。 第一行是对 shell 的声明，说明你所用的是哪种类型的 shell 及其路径所在。 第二行里 &amp;&amp; 左边是在判断是否有 .deploy/&lt;Name&gt;.github.io 文件夹，&amp;&amp; 右边是在说删除 .deploy/&lt;Name&gt;.github.io 文件夹，所以这行的意思就是如果有这个文件夹，就删掉它 第三行的意思是把你 &lt;Name&gt;.github.io 仓库的文件拷贝到本地的 .deploy/&lt;Name&gt;.github.io 文件夹下面 第四行就是让 hexo 生成静态文件 第五行就是说把 public 文件夹下面的东西放到 .deploy/&lt;Name&gt;.github.io 第六行就是跳转到 .deploy/&lt;Name&gt;.github.io 目录下 第七，八，九行就是正常的 git 操作了。 所以现在你明白了每一步的作用，如果在使用过程中出现了问题就不必慌张了。 好了，这两个头疼的问题终于解决了！让我们继续下面的内容。 发布一篇新文章现在是不是迫不及待的想发布一篇博客了？ 你只需要输入 hexo new &lt;名称&gt;， 然后你会发现在 source/_post/ 里多一个文件，文件名与你输入的 &lt;名称&gt; 相同。 不过，你很快会发现这是一个以 md 为后缀名的文件，这说明它是一个支持 Markdown 语言的文件，那么什么是 Markdown 呢？ Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 所以你大概已经明白了，MarkDown 是一种用于写作的语言，你如果想使用目前的这套技术方案来搭建自己的博客，就必须使用这个语言，其实说真的，这个没啥难度，可以参考下面的几个资料学习下： Markdown 发明者写的说明文档：http://daringfireball.net/projects/markdown/syntax 热心群众翻译的中文版：https://github.com/othree/markdown-syntax-zhtw/blob/master/syntax.md GitHub 提供的 Markdown 游戏，边学边玩：http://www.markdowntutorial.com/ Markdown 语法的 cheatsheet: https://guides.github.com/pdfs/markdown-cheatsheet-online.pdf 至于用什么来编辑 md 文件，我自己是目前是在用 MacDown，受限于 MacDown 的归纳能力，我目前在观望 Quiver和 MWeb。 总之，这些都不重要，哪个看着顺眼就用哪个！ 关于创建文章的一点补充如果仔细看 Hexo 的文档，我们就会知道创建文章的完整命令如下： 1$ hexo new [layout] &lt;title&gt; 我想跟大家说的有两点： 第一点，就是 title 参数为什么我会用 “ ” 号包起来，因为不用这个双引号包起来的话，我们文章的标题如果有空格的话，就会出问题了，用这种方式的话，即使你再双引号里面有空格，Hexo 在实际生成文件名的时候也会用 - 来替代它，所以这只是一个避免错误的小技巧而已。 第二点，就是 Hexo 支持模板这个概念，对应到这个命令里面就是的 layout 参数，对应到我们的文件里就是指 scaffolds 文件夹，那么这个概念是什么意思呢，也就是说我们不同的文章会有一些固定的格式，我们可以为这一类固定格式的文章建立通用的模板，这样我们就不用在每次创建文章的时候输入相同的内容。关于这个话题的一些高级使用技巧我就不在这里展示了，你完全可以直接查看 Hexo 的官方文档：https://hexo.io/zh-cn/docs/ 现在你已经搭建好了博客，也知道如何简单的使用这个博客系统了，那么这一篇的内容也就到此结束了。 下一篇我们会来讨论一下如何让我们的博客看起来更漂亮点。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[A Guide Of Making Your Personal Blog - Part 3]]></title>
      <url>%2F2017%2F03%2F24%2FA-Guide-Of-Making-Your-Personal-Blog-Part-3%2F</url>
      <content type="text"><![CDATA[在这篇文章里我们会说说域名解析的话题。不过这次我们会先进行具体的操作，再解释这些操作背后的含义。 域名解析估计你已经十分讨厌我每次在开干前的废话，所以我决定这次咱们先开干！走起 在 DNSPods上进行操作 登录 DNSPods 官网： https://www.dnspod.cn/ 注册 DNSPods 账户，这一步咱就不废话了 注册成功后，用用户名登录，点击左边的“域名解析”, 然后点击“添加域名”, 点击域名添加以下两个记录. 另外 name.github.io 中的 name 是你 GitHub 的用户名。 主机记录 记录类型 线路类型 记录值 MX优先级 TTL @ CNAME 默认 name.github.io. 无输入值 10 www CNAME 默认 name.github.io. 无输入值 10 在 GoDaddy 上进行操作 登录 GoDaddy 的账户，点击自己账户里的 My Products 选项。 在弹出的界面里面选择 Domains 一行的 Manage 按钮 点击左边卡片中右上角的齿轮按钮，然后再点击 Manage DNS 按钮 在 Nameservers 卡片中修改 NameServe 为 f1g1ns1.dnspod.net, f1g1ns2.dnspod.net 在 GitHub 上进行操作 打开我们在 GitHub 上的仓库，点击 Settings 按钮 在 GitHub Pages 的选项卡中的 Custom domain 中填写你自己购买的域名 测试一下好了，现在所有的操作都做完了，在浏览器里输入一下你自己购买的域名吧，那个熟悉的页面又出现了，只是这次的网址变成了你之前购买的域名。 我们都干了些什么？不过，你明白刚才做的这些事情都代表什么意思么？如果出了问题应该去寻找那方面的资料呢？是不是感觉有点不知所措。所以我们还是静下心来看看我们这些操作到底都代表着什么意思。 解释下在 DNSPods 里的操作首先，我们注册了一个 DNSPods 账号，并做了一些操作。 在解释这些操作之前，我们得先说明一下 DNS 和 DNSPods。 DNS 的全称是 Domain Name System，所以通过字面就可以理解出它其实是一个域名解析系统，用于解析域名对应的服务器。 DNSPods 是一个提供 DNS 服务的公司。当然还有其他提供 DNS 服务的公司，如果你想用别的也完全 OK。 我们在 DNSPods 里面进行域名解析的时候到底又做了哪些工作呢？让我们重新看下刚才填写的表格： 这里面的名词包括，主机记录，记录类型，线路类型，记录值，权重，MX 优先级，TTL ，它们分别代表着什么意思呢，我们来一个个解释。 主机记录用于设置域名的前缀，用于告诉 DNS 服务器把 “域名前缀 + 域名” 的链接与记录值中的地址关联到一起，例如我们在主机记录里输入 www ，记录值里输入 baidu.com ，就代表我们把 www.sketchk.xyz 与 www.baidu.com 关联到一起。当然不同的前缀有不同的意思，常见的有： www：表示解析域名 www.skethck.xyz @：表示解析主域名 sketchk.xyz 记录值是用来填完我们购买的域名地址或者服务器的 IP 地址。 如果我们在记录类型里选择了 A 记录就在记录值里填写服务器的 IP。 如果我们在记录类型里选择了 CNAME 记录就在记录值里填写我们购买的域名。 记录类型是用于区分记录值的类型，不同的记录类型要填写不同样式的记录值 线路类型是说我们让哪些线路的用户可以访问这个域名。举个例子，如果我们指定了电信用户，那么联通用户就无法访问我们这个域名，通常我们选默认就好。 TTL 是 Time To Live 的缩写，它表示一条域名解析记录在 DNS 服务器中的存留时间，单位是秒，所以 600 是表示 10 分钟的意思。 权重和 MX 优先级 跟我们做博客这件事没有太大关系，就不废话了 在这里估计有人会问，我们使用的是 GitHub Pages 服务，并没有实际去购买一个服务器，那么我们怎么去获得这个 IP 地址呢？ 其实在 GitHub 的官网上就有解释，具体详情请点击这里。 如果你仔细读了 Customizing GitHub Pages 的这篇文档，就会发现 GitHub 推荐在 DNS 里面使用 A 记录和 CNAME 结合的方式解析，而我在之前使用的是 CNAME 记录的方式，那么我们就改一下吧。 解释下在 GoDaddy 里的操作现在把我们在 DNSPods 里面干的事情算是搞明白了，我们是告诉了 DNS 服务器应该如何解析我们购买的域名，那么下一步就是告诉我们的域名在解析的时候去找刚才配置过的 DNS 服务器。 好了，让我们回顾下刚才填写的内容。 估计有些好奇的小伙伴一定会好奇，为什么我们要填写 f1g1ns1.dnspod.net, f1g1ns2.dnspod.net，而不是其他的值，原因很简单，DNSPods 在它的使用手册里面说明了它们的地址就是这样的。如果有任何疑问可以看它们提供的帮助文档。 所以如果你没有使用 DNSPods 作为你的 DNS 服务商，只需要找到对应的地址并填写到 Nameservers 里面即可。 解释下在 GitHub 里的操作回顾下我们前面做的事，我们在 DNSPods 里面给出了域名和服务器的映射关系，然后我们告诉了域名商在解析时候去 DNSPods 里进行解析，这样它们就可以找到对应的服务器 IP 地址了，用一个流程图来表示的话，就是下面的样子： 如果你对上面这幅图有疑问，可以在终端里面输入 dig sketchk.xyz ，dig www.sketchk.xyz，dig github.sketchk.io 来查看具体信息 这一切看起来都能解释清楚，但我们想想 Github 的服务器上不光有 sketchk.github.io 的仓库，也可能有 abc.github.io 的仓库, 还会有 Pop , AsyncDisplayKit 等一堆第三方仓库，那当我们通过自定义域名（例如 sketchk.xyz）找到这台服务器的时候，服务器是怎么把正确的资源返回给我们的呢？ 如果你不太明白我在说什么的话，请回顾 在 GitHub 上进行操作 一节的内容并删除 Custom Domain 中的内容，然后你再访问下自己购买的域名？ 是不是 404 了！ 但如果你访问 GitHub 自动分配的那个域名（例如给我分配的 sketchk.github.io），你会发现一切正常。是不是很有意思？ 所以我们需要确定一个 GitHub 和 自定义域名的对应关系，这样当你访问 GitHub 的服务器的时候，GitHub 就知道应该返回给你什么样子的资源了。 心细的朋友可能会问，这个对应关系到底是怎么进行的呢？ 我自己做了一个实验，将 Custom Domain 改为了 sketchktestforfun.xyz, 此时无论你访问 sketchktestforfun.xyz 还是 sketchk.xyz 都会发现网站无法正常展示。 不过我们可以尝试用下面的方式来访问域名，比如把请求的 Host 改为 sketchktestforfun.xyz 1$ curl -v sketchk.xyz -H 'Host: sketchktestforfun.xyz' 通过上面这个图，我们发现使用 sketchk.xyz 这个域名又可以访问到 sketchk.github.io 的资源了，这说明如果一个域名最终指向 GitHub 的服务器，当我们修改其 Host 为自己的仓库名时，它们最终都会访问到我们自己的那个仓库，这也又一次证明了在 Custom Domain 中填写的内容是为了让服务器知道如何响应不同的网络请求。 估计这时候一些朋友会惊慌失措的说道：“如果我在 Custom Domain 里填写的域名跟人重复了的话，该怎么办？” 对于这个问题，我们必须先搞清楚一件事，就是你在购买域名的时候，域名商一定不会卖给你一个已经被人买走的域名，Don’t panic！ 这里还有一些朋友会说我在一些文章里面看到的操作不是这样的，他们都是在对应的仓库里面添加了一个 CNAME 文件并在里面写上自己购买的域名。 其实吧，这两种做法是一样的，只不过 GitHub 以前没有提供这样一个简便的操作，所以之前的人会用创建 CNAME 的方式完成这个对应关系，但现在 GitHub 提供了这个功能，咱就怎么简单怎么来吧！ 好了，终于把这一章的内容写完了，让我们休息一下，开始下一章的内容吧！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[A Guide Of Making Your Personal Blog - Part 2]]></title>
      <url>%2F2017%2F03%2F24%2FA-Guide-Of-Making-Your-Personal-Blog-Part-2%2F</url>
      <content type="text"><![CDATA[这篇文章会围绕域名和服务器的话题展开，同时也会说点关于 Git 的话题。 域名搭建个人博客这件事，首先一定要弄个域名吧，要不然怎么彰显这是你的个人博客呢？ 在 GoDaddy 上购买域名购买域名的话，其实仁者见仁，智者见智，我个人是在 GoDaddy 上买的, 当然，你要想在 阿里云 上买也 OK，毕竟条条大路通罗马，不过在这里我就以 GoDaddy 为例好了。 注册并登录 GoDaddy 这种事我就不细说了！聪明的你一定可以完成的！ 在搜索栏里寻找你感兴趣的域名，其实你随便输入一个字母就好，比如 sketchk 验证域名是否可用, 如果当前域名不可用会有提示，如果可用就会自动加到购物车 选好以后点右上角的 Continue to Cart 按钮 稍等一会，你会进入到下面的页面， 第一个选项卡是在说，注册域名时，您的姓名、地址、电子邮件地址和电话号码都会自动发布到网上，大家都可以看见。借助 GoDaddy 隐私保护来保护自身免遭垃圾邮件和网络欺诈的侵害，它会将您的个人信息替换为 GoDaddy 的信息。 第二个选项卡是在说你是否愿意使用 GoDaddy 提供的搭建网站服务，也就是 GoCentral 服务。 第三个选项卡是说是否需要提供一个与你注册域名一致的邮箱地址。 这些都是附加服务，如果你感觉有必要就买好了，当然如果你觉得都没必要，也完全可以都不选。 接下来就是填写一些个人信息了，这一步按照自己的情况填写就好。 最后就是付款了，记得在付款的时候去 独特优惠码 上找点折扣，毕竟能省就省点呗。 付款结束后，你的注册邮箱会收到一封确认邮件，恭喜你，你现在拥有一个域名了！ 好了，做完这些就代表你已经处理完与域名相关的大部分事情了，剩下的一些事，我们会在 域名解析 一节里完成，下面我们来说说服务器！ 服务器在前一篇文章中，我们已经说了服务器像一个存放资源的地方，而存放资源的时候，你可以用一个小型仓库，也可以用一个中型仓库，甚至可以用一个大型仓库。那么我们应该选一个什么样的服务器呢？ 关于服务器的几件事用于搭建网站的服务器大概有以下几种：虚拟主机，虚拟专享服务器以及专属服务器，它们之间的区别可以参考下图的说明： 像我们看到的大多数网站，其实都是“放”在服务器上的，然而，这个“放”其实并不像我们想的那么简单。 如果你不太理解的话，让我举个可能不是那么恰当的例子吧！ 假如现在你已经拥有了一个域名并用 HTML，CSS，JavaScript 写好了一个堪称完美的网站，现在你把这些文件放在了某个服务器的磁盘中，那么你在另外一个电脑的浏览器里输入自己的域名会看到对应的网站么？ 答案肯定是看不到的！ 因为我们必须告诉服务器去监控各种各样的网络请求，让它能够对这些浏览器发送的网络请求进行分析，以便服务器能够知道这个请求到底想干嘛，然后再把这个请求想要的信息（例如 HTML，CSS，JavaScript）返回给对应的浏览器，这样你就能在浏览器上就能看到正确的内容了。 小白：额，什么是网络请求啊？SketchK：当你在浏览器上输入一个域名并敲击了回车就完成了一次网络请求！ 所以说了这么多，你是不是突然意识到买服务器只是“服务器”这个 topic 里的一小部分。不过不要担心，因为我们还有更简单的办法，比如 GitHub Pages! Github Pages 是 GitHub 公司提供的免费静态网站托管服务，所以从严格的角度上说，GitHub Pages 并不是一个服务器，它只是提供了一种类似服务器的服务！那么这个服务到底是什么呢？ 简单来说就是：如果我们将写好的 HTML 等文件放到 GitHub 的指定位置时，GitHub Pages 就能对这些文件进行处理并把它们展示成一个网站，同时还会自动给这个网站提供一个特定的域名。假如我们对 GitHub Pages 提供的域名不喜欢，我们完全可以把域名改成我们自己想要的！ 所以仔细理解下这个服务的内容，是不是很符合我们的需求! 我们只需要将资源放到 GitHub Pages 要求的地方就等于拥有了一台服务器。 假如我们对 GitHub Pages 提供的域名不喜欢，我们还能把它换成在 GoDaddy 上买到的域名。 好了，现在我们已经有解决方案了，那么我们将按照下面三个步骤来进行操作: 安装 Git 注册 GitHub 账户 开启 GitHub Pages 服务 稍微等一下！Git, GitHub, GitHub Pages 这些都是神马东西！我已经完全不知所云了！Take it easy! 让我来简单的说明下吧： Git 是一种软件，通过它可以控制代码的版本 GitHub 是一个代码的托管平台，支持 Git 作为其代码的版本控制软件 GitHub Pages 是…(我刚才不是说过了么，忘了就自己看看上面的解释吧) OK，废话就此结束了，准备实战！ 安装 Git 如果你已经安装过 Git 了，那就跳过这一节吧！ 登录 Git 的官网：https://git-scm.com/ 点击右边的 DownLoads For Mac 按钮 后面的事，咱就不用废话了。记住，安装完以后，在 terminal 上输入 git --version 来查看 Git 版本，只有安装成功才会显示出你的 Git 版本，所以你也可以通过这个方式来确认自己是否安装成功！ 注册 GitHub 如果你已经注册过一个 GitHub 账户了，那就跳过这一节吧！ 登录 GitHub 的官网：https://github.com/ 点击 Sing Up 进行注册，注册的过程就不细说了，你肯定能搞定的！ 在注册邮箱里面查收激活邮件并激活 GitHub 账户。记住，一定要激活！否则后面无法使用 GitHub Pages 服务。 设置 Git 的用户信息 在命令行里输入： 12$ git config --global user.name &quot;Your GitHub Name&quot;$ git config --global user.email &quot;Your-GitHub-Email-Address@example.com&quot; 配置 SSH Key 创建 SSH Key。在用户主目录下，看看有没有 .ssh 目录，如果有，再看看这个目录下有没有 id_rsa 和 id_rsa.pub 这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开终端，创建SSH Key： 1$ ssh-keygen -t rsa -C "Your-GitHub-Email-Address@example.com" 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到 .ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人。 登陆 GitHub，点击自己的头像，选择 Settings，再点击左边的 SSH and GPG keys 页面： 然后，点 Add SSH Key，填上任意 Title，在 Key 文本框里粘贴 id_rsa.pub 文件的内容： 最后在终端里验证下是否配置成功 1ssh -T Your-GitHub-Email-Address@example.com 如果在过程中遇到下面的提示, 不要紧张，输入 yes 就好。 123The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 开启 GitHub Pages 服务 温馨提醒：执行这一步时，一定要确保之前的配置都已经完成了哦！ 创建仓库 点击右上角的 + 号后，选择 New rpoository，会进入如下界面： 在 Repository name 下填写 Your-GitHub-Name.github.io，Description 下填写一些简单的描述，另外记得勾选下 Initialize this repository with a README 选项， 测试一下在执行完上面的步骤之后，我们可以在浏览器中输入 https://Your-GitHub-Name.github.io/ 这个网址, 记住 YourGitHubName 代表你自己的 GitHub 用户名。 如果你能看到一个十分简陋的界面，就像下图所示一样,那么恭喜你。你已经成功开启了 GitHub Pages 服务啦。 字号大的文字内容是仓库名称，字号小的是仓库信息。 好了，关于域名和服务器的话题也算告一段落了。下一篇文章我们会说说博客框架的内容！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[A Guide Of Making Your Personal Blog - Part 1]]></title>
      <url>%2F2017%2F03%2F24%2FA-Guide-Of-Making-Your-Personal-Blog-Part-1%2F</url>
      <content type="text"><![CDATA[这篇文章先说说搭建个人博客中常见的基本概念吧。 Before All在搭建好这个博客之前，不是赶上工作比较忙碌，就是在实际操作中遇到了自己无法理解的问题，总之这件事就是一直没弄好。 说到这些无法理解的问题，就不得不说一下如果你用 Google 搜索关键字 - 使用 Hexo 搭建博客 ，还是能搜到很多不错的教程在说这件事，可是这些教程更像一些操作手册，只是机械的告诉你第一步该干嘛，第二步该干嘛，第三步该干嘛，也不会给你讲讲为什么要这么做。 对于我这种之前没有搭建网站经验的人来说，一旦文章里说的事模棱两可或者文章里提到的内容和实际操作有出入，比较简单的问题还能处理，比较复杂的就完全不知所措，只能自己一遍一遍的去摸索。 不过我觉得最可怕的不是弄错了，而是不知道哪里出错了，以及这些问题背后的含义。所以就有了这几篇文章。 Core Concept先说说搭建个人博客里面常会提到的三个词：域名， 服务器，博客系统 我去理解这些概念的时候，是给它们做了一个类比：好比你家楼下的小超市（一个已经搭建好的个人博客），我们把它的地址看成域名，把它的库房来看成服务器。而整个超市的运营和管理等工作系统抽象成博客系统。 那么通过这样的类比，我想大概你马上就能明白: 域名是用来表示描述网站的具体位置，它解决的就是为什么我的博客地址叫 www.sketchk.xyz , 而不是 www.baidu.com 。 服务器是用来存储网站资源的地方，它解决的就是博客里的图片，文字等资源到底放在了哪里。 博客系统是让用户在互联网上建立个人博客的系统，它包含了如何构建博客，如何发布博客，以及如何管理博客等等一系列内容。 在文章里面还经常会提到一个名词：域名解析 这个事就好比我告诉你：“Hi，我们一会在大悦城见面吧！”，你肯定会问哪个大悦城？而不是直接杀向朝阳大悦城，万一我人在西单大悦城呢… 我们还是用一个例子来说明域名解析，虽然我的博客域名叫做 sketchk.xyz，但它只是一个域名而已，如果你想看我的博客，还是要去存有我博客资源服务器里获取信息，那么通过这个比喻我想域名解析的意思就可以理解为帮助域名找到对应的服务器。 好了，概念就这些，希望没有把你搞糊涂了！ Our Goal一想到自己马上就会有个非常 cool 的个人博客是不是有点激动呢！ 不过这个概念实在太模糊了，我们还是要把事情具体化一下，就好比说当你看完这篇文章以后到底会弄出来什么东西呢？ 我的预期目标是你的博客可以有以下几个特点： 有一个你亲自挑选的域名 使用 GitHub Pages 服务解决服务器的问题 使用 Hexo 框架来做你的博客系统 使用 NexT 主题并做一些自定义的设定 使用 Travis CI 实现博客的自动部署 这些东西现在看起来有点似懂非懂，不用着急，慢慢把这几篇文章看我，你就会明白我说的这些东西都代表什么意思了！ 这一篇的内容就到此结束了，下面我们会讨论域名和服务器的话题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode 8 的 Debug 新特性 ---- WWDC 2016 Session 410 & 412 学习笔记]]></title>
      <url>%2F2016%2F10%2F20%2FNew-Debugging-Feature-In-Xcode8%2F</url>
      <content type="text"><![CDATA[把最近学习的两个关于 debug 的 WWDC 跟大家分享下 : ] Overview本文针对 WWDC 2016 Session 410 和 412 以及 WWDC 2015 Session 413 中的内容进行了整理. 文中主要倾向于如何使用,以及这些工具的使用场景, 如果想了解这些工具的工作原理或者细节方面的东西,请大家观看原视频即可.具体链接在文中最后的参考资料里. 废话少说,接着往下看吧. Static AnalyzerStatic Analyzer 是一个常见的 debug 的工具, 苹果工程师在 WWDC 中是这样介绍它的: 不需要 running code (unlike sanitizers) 在处理 edge-case 的 bugs 时, 有着优异的表现 支持 C, C++ 和 Objective-C 如何使用 Static Analyzer使用 Static Analyzer 很简单, 你可以通过选择 Product -&gt; Analyze 或者 Cmd + Shit + B 的方式执行, 如果有错误,就会在 Issue Navigator 上显示出来 在今年的 Session 412 中, Apple 的工程师告诉我们在 Xcode 8 中, Static Analyzer 能够检测出三种新的错误, 它们分别是: Localizability Instance Cleanup Nullability 看英文有点不好理解,不用担心,接着往下看,咱们一个个的说. LocalizabilityLocalizability 其实说的是 Static Analyzer 现在能够检测出本地化信息缺失的问题,目前能够检测出来两种类型的错误, 一种是没有使用 NSLocalizeString 这样的 API, 而直接给控件设置 Sting 的情况, 一种是使用了相应的 API, 但在 comment 信息里面赋值为 nil. 如果有错, 就会像下图一样, 在代码下方出现一个蓝色提示条, 告诉开发者具体的错原因. 在 Xcode 里,检测第二种类型的错误并不是默认开启的,如果想开启,需要在BuildSting 中进行如下设置: Instance CleanupInstance Cleanup 说的是什么呢? 这说的是在 MRC 的代码中, 尤其在 dealloc 中,我们不应该对 assign 类型的属性进行 release 操作,应该对 retain 或者 copy 类型的属性进行 release 操作, 如果不这样操作的话,会引发一些不必要的麻烦. 不过现在有了 Xcode 8, 这些问题就交给 Static Analyzer 吧,它能够很准确的检测出这样的错误. Anyway, 还是建议你把代码转成 ARC 吧! 不知道怎么转, 看下图 Nullability关于这个话题是说的什么呢? 首先我们得先说说在 2015 年的 WWDC 大会上, Objective-C 引入的一个新特性就叫做 Nullability, 用于表明一个东西到底可以为 nil 还是不可以为 nil , 这和 Swift 里的 option 类型很相似. 既然知道了这个玩意后,我们再说说 Static Analyzer 在这一块到底能够干点什么? 通俗的说, Static Analyzer 可以检测出在不同场景下是否做到了 nullability 的一致性. 那么我们一般什么时候会出现 nullability 方面的错误呢? Objective-C 与 Swift 混编的场景 在代码中有一些逻辑错误 不正确的注释 我想看到这,很多朋友都会对这个功能嗤之以鼻, 并且想着”我只要不使用与 nullability 相关的关键字, Static Analyzer 就肯定不会报错啦.”, 确实从某种角度来说, 你这么干以后, Static Analyzer 确实不会报错了,但这样真的好么? 这就回归到为什么我们需要使用与 nullability 相关的关键字这个问题上, 我认为主要的原因有三个: 便于跟 Swift 的交互 方便使用者明白开发者的意图 能够将一些不必要的问题提前到编码阶段, 而不是到用户使用时才暴露 估计有的朋友会对我的第三个观点不太理解, 不用在这里纠结, 下面的这个例子会解释我的想法. 首先看这段代码, 我们假设他的使用场景如下, 这是一个类似地理位置的抽象类, 对于这样的类,它可以有一个方法来描述它所在的城市或者国家, 这个方法看起来是没有任务错误的, 但其实里面是有缺陷的, 现在假设我们在大西洋的某个不知名的海域中, 由于这个地方既不属于某个城市, 更不属于某个国家, 那么由于 name 的初始值为 nil , 那么他的返回值一定为 nil, 这就与 API 设计者规定的 nonnull 相互冲突了, 万幸的是 Static Analyzer 帮我们检测到了这一切. 但假如我们没有使用 nonnull 关键字呢? 那么这段话本来是要用于展示在某个 label 上的,但由于返回值为空, 屏幕上空空如也, 用户好几脸懵逼, PM 和 QA 的同事火速杀到你的工位前……总之,不用我说,你应该能明白我意思了, 这就是我说的: 能够将一些不必要的问题提前到编码阶段, 而不是到用户使用时才暴露 我们再来看一个例子说明下不正确的宏注释产生的问题,在NS_ASSUME_NONNULL_BEGIN 和 NS_ASSUME_NONNULL_END 之间的属性都会被默认为 nonnull 类型, 那么看下面的代码: 在日常的工作中,我们经常是从某个人手里接过来一段代码进行开发, 假设在这个文件里, 由于整个代码已经到了近 1000 行, 且有好几个类在同一个 .m 文件中, 所以两个宏写的非常隐蔽, 你根本没有察觉到它们的存在. 然后你很自信的声明了一个再普通不过的的 pressure 属性, 并重写了它的 get 方法, 同时我们的逻辑很清楚, 这是一个人拥有的方法, 如果他有压力计的话就测量一下压力,并返回这个压力值,如果没有压力计的话,就返回 nil , 这个逻辑看起来是如此的正确, 但你一运行就 crash , 是不是很崩溃. 好在 Static Analyzer 告诉了我们问题的关键, OK, 这个 bug 很快就能解决了. Runtime Issue说完了Static Analyzer, 我们来说说 Runtime Issue 这个东西,就像下面这个图展示的一样, 你可以认为以后见到这个紫色的感叹号标志就是一个 runtime issue , 哦, 顺道说一下左边的两个分别是 Error 和 Warnning 状态, 右边的两个分别是 Static Analyzer Issue 和 UI Test Failed 的状态, 不同于其余这些东西的出现时间, runtime issue 是出现在程序运行期间的 目前支持 Runtime Issue 的工具有三个, 分别是 Debug View Hierarchy , Thread Sanitizer 和 Debug Memory Graph , 我们会在下面的话题一个个介绍给大家! 嗯呐, 总之, Runtime Issue 的话题就告一段落啦. View Debugging EnhancementsView Debugging 到底指的是什么呢? 我想各位看英文时候可能有点懵逼, 但看完下面两张图是不是瞬间明白我在说神马了!!! 嗯呐, 就是这个功能叫做 View Debugging, 也可以叫做 Debug View Hierarchy, anyway, 你喜欢啥就叫啥吧, Enhancements这个功能在 Xcode 6 就有了, 那么在 Xcode 8 上又有了哪些提升呢? 苹果工程师给出答案是这样的, up to 70% faster snapshots layout and transform accuracy blur rendering navigator filtering jump to class auto layout debugging 至于第一个改进点,大家可能需要自己去感受,我也确实没有兴趣做一个数据对比, 毕竟 PM 还找我做需求呢…那么我们说下后面五个改进点吧. layout and transform accuracy这到底是说神马呢? 难道是说以前的 layout 和 transform 不准确么? No, No, No, 并不是说以前不准确,而是说现在比以前更精确了, What, 我说的话是不是好绕,还是直接上图吧… 所以说你看出来神马名堂了么? 在 Xcode 8 里能够更加精确的表明这些约束的意义, 例如是否是等比例缩放(第一张的比例值), 是否是权值较低的约束(第二张的虚线段), 是否是一个不绝对相等的约束(第三张的小于等于). 这些在 Xcode 7 里都是没有体现出来的, 总之通过这些标记, 能够让我们更加清晰的了解到这些约束的意义, 而不只是一根实线而已 blur rendering这是说在新的 debug 模式下,我们能够看到 blur 层了. 是不是很美好 navigator filtering这个东西我觉得还是蛮好使的, 因为原先在 Navigator 里找某个控件时, 真的很难, 尤其在那种结构复杂的界面里, 就看着自己点着那个三角按钮一遍又一遍的… Xcode 8 在今年很好的解决了这些个问题, 我们现在在 Navigator 中可以通过控件的内存地址来定位, 也可以通过它的类名来定位, 甚至可以使用控件中展示的 String 内容来定位. 这样一来, 找控件就变得很 easy 了, 是不是!!! 不信, 你看下面的这张图. jump to class这个新增的功能充分体现了苹果工程师的人文关怀, 试想一下, 我们每次在定位到对应的控件后, 如果想要修改其 layout 的相关属性时, 有些人会到左边的 Project Navigator 中的层级结构里找对应的.m或者.h文件, 熟悉快捷键的人可能会用 `Cmd + Shit O `直接跳转到对应的类中, 总之,你都得想想这个东西的类名, 并输入点字符神马的, 很麻烦. 但在Xcode 8 之后, 我们只需要去 UI 控件的 Object Inspector 的界面里点一下右边深灰色的前进按钮, 嗖的一下,我们就跳转到了对应类的文件中 auto layout debugging这个功能就要结合之前的 runtime issue 话题了, 废话少说, 先上个图给你们瞅瞅. 我们可以看到,如果我们在布局控件中有错误的话, 我们点击 Debug View Hierarchy 后, Xcode 8 就会报出来一堆 Runtime Issue , 这个功能是不是很吊, 以后写约束再也不怕不怕啦, 毕竟有错, 咱们就按提示改呗. Debug Workflow这一块的内容并不是某个 Session 里提到的, 而是我在看这些个 WWDC 后总结出来的, 你可以发现苹果的工程师在解决这些问题时, 都是有一个套路的, 套路的英文我也不知道是啥, 就用个 workflow 吧.他们在解决带有 runtime issue 的问题时, 都会遵循这样一个解决思路 Activity Viewer : 查看 Activity Viewer 上是否有错误提示 Issue Navigator : 在 Issue Navigator 上初步了解错误的类型 Debug Navigator : 在这些界面上了解其层级结构, 调用顺序, 堆栈信息, 对象持有的层级结构图等信息 Inspector : 查看具体的细节,并分析错误的原因 Source code : 使用 jump to class 功能进入源代码,并修改 至于这个东西, 我觉得可能需要大家自己在实践中慢慢体会, 才会更深入的理解为什么会有这些 debug 工具的产生和为什么他们要在这里提示.当然这也是个仁者见仁,智者见智的问题, anyway 你若安好, 便是晴天! Memory Graph Debugging讲完了 View Debugging Enhancement , 我们来说说今年 Xcode 8 推出的 Memory Graph Debugging. 最近看到很多公众号和微博都有朋友在说这个特性, 我在这里就不花费太多的篇章去讲它, 更多的说说我觉得在其他文章里没提到的东西吧. 在说这个东西之前, 不知道大家是否知道以下三个命令, 如果没有大家不妨在自己的机子上试一试 123$ heap YourAppName$ leaks YourAppName$ malloc_history YourAppName Address 好吧,假设看到这时, 你已经按照我说的那样,按使用了上面的几个命令, 那么下面我就得告诉你一个真相. 其实 Memory Graph Debugging 就是把这样的一套东西变成了UI界面而已. How to use那么我们接着说说如何使用它吧, 它的使用方式很简单, 在 app 运行的时候, 点击 Debug View Hierarchy 按钮旁边的 Debug Memory Graph 按钮即可, 对就是那个三个圆圈两个线的按钮. 哦, 对了如果你想看到对象的 malloc_history, 记得在 Diagnostic Scheme Tab 页面里面选择 Malloc Stack , 否则你是看不到任何信息的, 命令行也是如此, 另外, 苹果的工程师还说如果勾选了 Malloc Scribble, 整个结果会更加精确 那么我们来看看点击 Debug Memory Graph 按钮后的效果吧 通过这段时间的使用呢, 大致总结出来这样的一些规律 绿色的一般都是 UIKit 控件及其子类 蓝色一般 NSObject 类及其子类 黄色一般都是容器类型及其子类 灰色括号是指 block 当然还有很多一些其他的类型,具体的大家去看右上角的 Memory Inspect 界面就好,上面都会有详细的信息 另外这一块还要跟大家交流的就是在 Session 410 中, 苹果的工程师说了一些内容, 希望开发者们在使用 Memory Graph Debug Tool 时能够知道: 为了避免误报内存泄漏的问题, 苹果在展示 Memory Graph 时, 增加了一些引用, 这些引用只是为了避免误报 在 Memory Graph 所有的强引用都是黑色实线, 而灰色实线并不是弱引用, 只是一些系统级别的引用或者苹果为了优化显示效果而添加的, 就像上面第一条说的那样, 所以在看到灰色的引用时, 就自动忽略它吧 关于运行效率方面, 苹果工程师也说了,如果只是为了看 Memory Graph , 在 Malloc Stack 选项中, 直接选择 Live Allocations Only 即可, 这样会避免过多的性能消耗 另外, Swift 3 在 Memory Graph 上的表现要相对较好一些 Sanitizer 与这个功能不能同时开启, 至于为什么, 你自己看完这几个 session 就会明白了 .memgraph file另外 Xcode 8 专门提供了一个文件格式来保存某一时刻 app 的 Memory Graph, 当然这个文件你是没法 run 起来的, 它只是个graph, 你要明确这一点. 对于喜欢命令行的小伙伴来说, 苹果还提供了一下的操作指令 12$ leaks --outputGraph=&lt;path&gt; &lt;process&gt; //creates .memgraph file$ &#123;leaks|vmmap|heap&#125; &lt;path/to/file.memgraph&gt; [options] //operate on .memgraph file SanitizerWhat does Sanitizer mean?Santize在英文里面有美化, 优化的意思, 可想而知 Sanitizer 就是一个用于优化的工具.那么 Xcode 中的 Sanitizer 到底是什么呢? 在 WWDC 2015Session 413 中, 苹果的工程师给出以下条目来介绍 Sanitizer: Find bugs at run time Similar to Valgrind Low overhead Work with Swift 3 and C/C++/OC Integrated into Xcode IDE 那么到底 Sanitizer 在 Xcode 里怎么使用呢? 其实很简单, 打开 Product -&gt; Scheme -&gt; Edit Scheme, 就会弹出如下的界面, 我们在 Diagnostics 中能够看到这样一个标题 Runtime Sanitization, 在它下面有 Address Sanitize 和 Thread Sanitizer 两个选项, 我们只需要勾选相应的 Sanitizer 即可. 说到这里还必须多说几句, 此处如果你只是勾选了相应的选项并不代表你就能使用 Sanitizer 来 Check 代码了, 你还必须重新 run 一下代码, 为什么呢? 这就必须说说整个代码 build flow 了. 如下图所示, 通过勾选了对应的选项, Xcode 会向 clang 传递一个特定的参数, 然后生成一个独特的 binary, 然后这个 binary 会和 Thread Sanitizer 或者 Address Sanitizer 的 dylib 链接在一起. 这样 Sanitizer 就实现了它想要达到的功能. 至于每个 Sanitizer 的实现原理, 我这里就不过多描述了, 建议大家直接观看 WWDC 2015 Session 413 ( Address Sanitizer ) 和 WWDC 2016 Session 412 ( Thread Sanitizer ) , 我们这里还是着重介绍它们的使用方法和使用场景. 总之, 你需要记住的就是, 在使用 Sanitizer 的时候, 要重新 Run 一下代码哦. Address Sanitizer ( ASan )ASan 其实是 Xcode 在去年新增的一个功能, 它主要用于检测一些内存方面的错误, 在 Xcode 8 里, ASan 已经全面支持了 Swift, 这应该是它唯一新增的一个功能. 那么 ASan 到底能检查哪些类型的错误呢? 苹果工程师列举了以下六种: Use after free Heap buﬀer overﬂow Stack buﬀer overﬂow Global variable overﬂow Overﬂows in C++ containers Use after return 哦对了, 苹果的工程师还说后面四种是 ASan 独有的功能, 当然说这话的时候是 2015 年, 不知道 2016 年的时候, 其他的 debug 工具有啥进步没. 说了这么多,咱们来看看下面这段代码吧. 大家应该能够看出来如果用 buffer[80] 的话是会产生数组越界的问题, 虽然 malloc 了 80 个位置,但起始位置是从 0 开始的. 但现实呢, 这段代码在不开启 ASan 的状况下, 百分之九十九都不会产生 crash , 而且产生 crash 的时候也不会像图中红色文字那样明确的告诉你这是一个 Heap buffer Overflow 问题. 这就是 ASan 的作用, 所以如果再遇到内存问题, 不用再诚惶诚恐的改完代码后使用哎弥陀佛 Cmd + R 大法了, 是不是很 nice! Thread Sanitizer ( TSan )最近发现不少公众号和微博在说 Xcode 8 的新特性时, 都在说 Debug View Hierarchy 和 Debug Memory Graph 的相关内容, 但说实话, 我觉得今年 Xcode 8 最令人兴奋的就是添加了 Thread Sanitizer 这个功能, 说真的, 这个功能太有用了, 为什么呢? 让我们想想自己在调试线程方面的 bug 时, 有哪些令人记忆深刻的东西: 线程方面的 bug 对时间很敏感, 这就导致很多线程的 bug 极难复现, 复现都成问题, 还怎么改 bug 由于线程的抽象概念导致在 debug 时候也比一般的 debug 更费劲儿, 这时候总觉自己脑子不够使 有时候, 由于线程引起的 crash 或者 error ,让我们根本意识不到这其实是线程出了问题 相信上面的三点总会有一个让你刻骨铭心…… 那么我们赶紧说说怎么开启 TSan 来帮我们检查线程问题吧. 喂喂, 这个咱们就不再说一遍了吧, 记得看 ASan 章节里的那个图片, 在 Address Sanitizer 下面就行 Thread Sanitizer 啦. 至于 Thread Sanitizer 下面的那个 Pause on Issues 的选项就是说, 如果你想一个一个看 runtime issue 就勾选它, 如果你不想这样, 就不要勾选它, 具体是个神马感觉, 你自己试试喽. 如果你喜欢使用 Comman-Line ,那么请记住下面的代码 1234567891011121314151617181920//Compile and Link with TSan$ clang -fsanitize=thread source.c -o executable$ swift -sanitize=thread source.swift -o executable$ xcodebuild -enableThreadSanitizer YES//Stop after the first error$ TSAN_OPTIONS=halt_on_error=1 ./executable``` 哦, 还要加一句, TSan 现在只支持 64为 macOS, 以及 64位的 iOS 和 tvOS 的模拟器, 并不支持真机调试和 watchOS.那么 TSan 作为一个能够检查线程错误的工具, 它现在能检查哪些类型的错误呢? 苹果给出的答案如下:* Use of uninitialized mutexes* Thread leaks (missing `phread_johin`)* Unsafe calls in signal handlers (ex:`malloc`)* Unlock from wrong thread * Data race那么我们拿下面的这段代码来举例: (void)viewDidLoad { [super viewDidLoad]; [self resetStatue]; pthread_mutex_init(&amp;(_mutex), NULL);} (void)resetStatue{ [self acquireLock]; self.dataArray = nil; [self releaseLock];} (void)acquireLock{ pthread_mutex_lock(&amp;_mutex);} (void)releaseLock{ pthread_mutex_unlock(&amp;_mutex);} 123456789101112131415161718192021这段代码的意思是,我们在 viewDidLoad 方法里面重新 reset 自己的状态, 为了防止多个线程去访问同一个 dataArray 属性, 造成 data race 的状态, 我们在 resetStatus 的时候需要加锁, 但当前代码中,我们实际上调用的是一个没有初始化的锁 ( init 方法在 resetStatus 方法下面哦) , 但这段代码在实际运行的过程中,百分之九十九也不会出现 crash, 但有了 TSan 后, 我们来看看发生了什么变化![](http://upload-images.jianshu.io/upload_images/406302-9d2a08e5b865d35c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)发现 runtime issue 的标志了么! 看不清啊,那我们把左边的 Issue Navigator 放大一下![](http://upload-images.jianshu.io/upload_images/406302-a8a4442dbeee8fc5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)发现没有,在 Issue Navigator 中, TSan 明确的告诉了我们错误的类型, 而且把线程中的历史信息都记录了下来以便我们分析并解决这个问题, 有没有很贴心!通过这个问题, 你发现了什么问题么?* 首先 TSan 并没有触发 Crash 并且成功捕获到了这个线程问题, 这说明 TSan 不需要我们去复现 crash 来捕获错误* 然后你在不同机型, 不同环境下运行带有线程错误的程序, 你会发现每次 TSan 都能捕获到这个 bug, 这说明 TSan 对时间是不敏感的.这样安全可靠的 debug 工具你怎能不爱呢! 说道这, 不妨我们多说一点, 大家都知道 data race 是线程中最常出现的问题, 造成 data race 的情况无非就是两种, 一种是逻辑错误, 一种是没有加锁. 在这里我特别想分享一个我自己在使用 TSan 时编写的小 Demo. 我们先看一下代码的使用场景, 我们假设有三个售票员在卖票, 票的数量由 `ticketsCount` 决定, 同时我们将售票员抽象成一个线程类: self.ticketsCount = 100; NSThread *thread1 = [[NSThread alloc] initWithTarget:self selector:@selector(saleTicket) object:nil]; thread1.name = @”售票员1”; self.thread1 = thread1; NSThread *thread2 = [[NSThread alloc] initWithTarget:self selector:@selector(saleTicket) object:nil]; thread2.name = @”售票员2”; self.thread2 = thread2; NSThread *thread3 = [[NSThread alloc] initWithTarget:self selector:@selector(saleTicket) object:nil]; thread3.name = @&quot;售票员3&quot;; self.thread3 = thread3; 12然后我们执行下面的这段代码 for (NSUInteger count = self.ticketsCount; count &gt; 0; count--) { if (count &gt; 0) { [NSThread sleepForTimeInterval:0.1]; NSString *name = [NSThread currentThread].name; dispatch_async(dispatch_get_main_queue(), ^{ self.ticketsCount = count - 1; NSString *string = [NSString stringWithFormat:@&quot;%@卖了一张票, 还剩%zd张票&quot;, name, self.ticketsCount]; self.ticketsCountLabel.text = string; NSLog(@&quot;%@&quot;, string); }); } else { dispatch_async(dispatch_get_main_queue(), ^{ NSLog(@&quot;票卖完了&quot;); }); return; } } 1234567会发生什么呢? 显而易见,由于没有加锁, 售票员会卖出去不该卖出去的票![](http://upload-images.jianshu.io/upload_images/406302-fa93ac20dfdd9071.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)那我们加个锁试试? @synchronized (self) { for (NSUInteger count = self.ticketsCount; count &gt; 0; count--) { if (count &gt; 0) { [NSThread sleepForTimeInterval:0.1]; NSString *name = [NSThread currentThread].name; dispatch_async(dispatch_get_main_queue(), ^{ self.ticketsCount = count - 1; NSString *string = [NSString stringWithFormat:@&quot;%@卖了一张票, 还剩%zd张票&quot;, name, self.ticketsCount]; self.ticketsCountLabel.text = string; NSLog(@&quot;%@&quot;, string); }); } else { dispatch_async(dispatch_get_main_queue(), ^{ NSLog(@&quot;票卖完了&quot;); }); return; } } } 123456加锁后,我们发现售票员确实没有再卖出去不该卖的票,但是好像只有一个售票员在卖票. ![](http://upload-images.jianshu.io/upload_images/406302-06af1dd4b1f23cb0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)这显然是一个逻辑错误, 我们锁住更像是线程, 而不是资源, 所以我们再改进一下 while (1) { @synchronized (self) { if (self.ticketsCount &gt; 0) { [NSThread sleepForTimeInterval:0.1]; NSString *name = [NSThread currentThread].name; self.ticketsCount = self.ticketsCount - 1; dispatch_async(dispatch_get_main_queue(), ^{ NSString *string = [NSString stringWithFormat:@&quot;%@卖了一张票, 还剩%zd张票&quot;, name, self.ticketsCount]; self.ticketsCountLabel.text = string; NSLog(@&quot;%@&quot;, string); }); } else { dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@&quot;票卖完了&quot;); }); return; } } } ``` 来看看打印台的结果 看起来是不是特别完美! 不同的售票员在卖票, 而且也没有出现卖出去不该卖的票, 但是其实这段代码还是有潜在风险的. What? What? What? 怎么会有错… 这时候我希望你能打开 TSan 来分析下潜在的风险在哪里吧, PS: 如果你比较懒的话, 好好想想 dispatch_async 用的对么? 如果我在这里么加入了一些危险操作 ? 说到这, 你是不是又一次被 TSan 强大的功能震撼住了, 说真的, TSan 真的是 Xcode 8 里一个非常强大的新功能, 它能够帮我们察觉到很多很多我们自己完全意识不到的细小问题, 而在这些问题经常会弄得我们在 debug 时候苦不堪言, 所以从今天开始, 在你编程的时候, 用一下 TSan 吧 Recap总结一下今天我们到底说了些什么: 一种新的文件格式 : .memgraph 两个新的概念 : Debug workflow 和 Runtime issue 三类 debug 工具 : Sanitizer, View Hierarchy Debug Tool , Memory Graph Debug Tool 最后呢, 想说的很简单, Use this tools on our project and Make our app better than ever Reference MaterialWWDC 2016 Session 410 - Visual Debugging with Xcode WWDC 2016 Session 412 - Thread Sanitizer and Static Analysis WWDC 2015 Session 413 - Advanced Debugging and the Address Sanitizer]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FOUR - 一个27岁零基础无业游民的第一个开源作品]]></title>
      <url>%2F2016%2F07%2F26%2FFOUR-My-First-Open-Source-App%2F</url>
      <content type="text"><![CDATA[说一说我的第一个个人开源作品，它看似一篇技术文章，但也有点像鸡汤… 写在前面的废话 如果你不喜欢看废话，可以直接绕过第一段哦 : ] 我是一名 14 年毕业的研究生，当时的主攻方向是能源科技领域，离开校园后就去了上海的一家外企当起了管理培训生，后来还参与了朋友的创业项目，在外人看来，这样的生活还不错。但就是这样还不错的生活，让我一直隐约的感觉到不安，所以在去年的时候，我跟家人说想辞掉现在所有的工作，尝试去做一名程序员。 这样的决定让我的家人和朋友都十分不解，在他们看来我在本科和研究生阶段所学的东西都跟计算机沾不上边（事实情况也确实如此），而且我也已经27岁了，重新进入一个完全陌生的领域代价实在是太大了，虽然有很多不利的因素，但我在今年年初参加完 AtCont 在北京组织的 Swift 开发者大会后，终于下定了决心。 其实参加会议本身到没有什么内容刺激到我，因为当时参会的时候，我甚至都没看完 Swift Programming Language 这本书，现场听得懂的内容也屈指可数（PS :我可是全场唯一一个从新疆赶到北京参会的人啊，但当时我真的一点都不懂 Swift ……），但真正刺激到我的还是这个大环境，为什么这么说呢？ 这还要说到现场发生的一个小插曲，会议当天，坐在我前面的是一个帅哥，我完全不认识，大概没多久，我看到@周楷雯Kevin从前排起身要出去，刚好路过我这，本以为他就会这么走过去，但他突然停下来，好像认出了坐在我前面的男子，然后两人像老熟人一样说起了话，话里的内容一部分是互相寒暄，另一部分则是对对方作品的赞赏和肯定，后来我才知道坐在我前面的这位男子是奇点的作者@图拉鼎 先生，最神奇的是我当时最爱用的微博客户端就是奇点，而此时它的开发者就坐在我的面前…ORZ 这只是当天会议中的许多场景中的某一个片段，你可以在午休时段，看到很多开发者通过某个作品认识到了新的朋友，这让我觉得在这里，人与人之间的关系很简单，有时候可能就是通过在 GitHub 或者 App Store 上的作品，就能把两个完全不认识的，甚至不同肤色，不同国籍，不同语言的两个人联系到一块，这里不是一个靠关系，靠背景的地方，而是一个靠实力，靠能力来说话的地方。 Anyway ，就是这样一次看似简单的参会经历，让我决定了从零基础开始学习 iOS 开发。 FOUR 的由来开发这个 app 的初衷一方面是因为看完了《异类》这本书后颇受启发，一方面是觉得如果今后找工作的话，像我这样非计算机专业出身的开发者，怎么也得有个自己的作品才好，所以带着这样的目的，我决定开发一款基于 The 10000 Hour Rule 的 app 。 至于为什么叫 FOUR ，就像我在 app 的引导页中所说一样，假如每天花4个小时去做一件事，至少也需要十年左右才能达成一万小时的要求，所以照此推算，我们在六十岁的时候大概也就能实现四个人生大目标吧，所以就起名叫 FOUR 喽！ FOUR 的起点开发前的思考在开发这款 app 时，我曾经认真思考过到底用哪种技术来实现，纯 OC or 纯 Swift , 或者用 React-Native , Reactive-Cocoa ，RxSwift 的思想来实现？ 面对这些个选择，最开始的时候我是想着用点新技术，虽然使用新技术是体现自己的学习能力，但考虑到时间成本我决定还是先暂时放一放。 在 OC 和 Swift 的选择中，虽然现在大趋势是 Swift ，我自己也系统的学习了 Swift 语言，但考虑到3.0即将到来，我选择采用 OC 开发的策略，一方面可以避免 Swift 语言版本的更新问题，一方面我认为只有在同一个项目中使用两种不同的语言进行开发才可以更好的去理解这两种语言的差异和优劣，所以我不妨先用OC写一遍，等程序比较稳定且 Swift 3.0 正式发布后，我再用 Swift 写一遍，这样岂不是效率更高一些么？ 至于 React-Native，Reactive-Cocoa，RxSwift 这样的东西，如果以后有机会，当然也会来写一遍。 为什么？ 难道终身学习不是一个程序员的自我修养么！！！ 竞品分析关于 app 的 UI 设计，我觉得在某种程度上还是蛮重要的，毕竟用户不会直接看到你的代码写的多漂亮，逻辑有多清晰，架构有多合理，他们看到的只是你在手机上的展示的东西，所以 UI 设计的工作就显得尤为重要。周楷雯在 《Producter》 一书说道： “设计总是从模仿开始，在我的记忆里，第一次做设计是在 Ubuntu 7.04 上用 GIMP 制作壁纸，模仿 Mac 的霞光壁纸，那还是 2007 年的事。” 所以，我决定也从模仿开始做起，那么模仿什么呢？不如看看 App Store 里都有哪些 app 吧，于是我搜索了与 10000 hour rule 相关的 app ，在搜索前几名的 app 如下： iHouriHour 的功能十分丰富，但正因为丰富的功能设定，使得我在使用过程中显得有些不知所措，但是从功能和设计的角度上来说，这款 app 有不少值得我去借鉴的地方。 10,000 hours这款 app 虽然看起来相当简陋，也只能添加一个 Task ，但它给我最深刻感受就是简单明了，尤其在我进入 app 的主界面后，没有花费太多时间就能明白制作者的意图，并很快的熟练使用起来，这种设计理念我十分喜欢，虽然设计感还有待提高，但用户的体验还是很好的，这总比花了好几分钟都没有找到计时功能的 iHour 好很多。 Color Time这款 app 呢，我觉得最大的亮点在于 Task 中详细信息的展现上，可以看出开发者肯定是有想法的，不知道是受限于技术问题，还是设计问题，在最终的展现上让人看起来有些奇怪，但不可否认，开发者肯定是想以一种不同于前两个 app 的方式来表达 Task 中的详细信息。 10000 Hours To Success这个 app 在某种程度上和 iHour 十分相似，有着不错的 UI 设计，但复杂的操作和奇怪的逻辑让用户的体验感变差不少，尤其是它添加任务，记录任务的方式让我觉得实在太不人性化。 10000 Hours对于这个 app 而言，你看下面的截图就可以清楚的感受到它的优点和缺点。 Outliers - Law of 10,000 hours说实话，这个 app 的售价是 12 RMB，但我觉得这有点对不起它自己的售价。 在使用完上面六款 app 后，我总结了以下几点感受： 优雅的UI设计会为 app 增分，即使用起来有些别扭，毕竟这是一个看脸的社会 合理的交互设计会减少用户的学习负担，一个好的 app 不应该有过多的提示操作，而是应该以一种简明的设计方式来引导用户学习使用 对于类似 To-Do List 类的 app 而言，记录任务和展示信息是两个十分重要的环节，一方面这是用户使用频率最高的环节，一方面也是展现开发者智慧的地方 FOUR 的雏形关于界面设计FOUR 的设计灵感最初来自 noahbombom 在 Dribbble 上的设计稿，我被这个设计稿吸引的原因有两点： 一是因为图片上面刚刚好够展示 4 个图标。 二是其简单大方的设计感，让我很直观的感受到设计者的意图。 选定完样式以后，我就开始考虑 app 的配色问题， noahbombom 在她的设计稿上使用的是非常经典的四个颜色：红黄蓝绿，这四个颜色在很多知名的 app 上都有过不同的展现方式。 正因为红黄蓝绿的经典性，我考虑将其移植到我的 app 设计稿中。 关于字体设计前段时间， MartinRGB 在它的朋友圈里发表了一篇文章 - 惬读的设计，这篇文章对我的感触挺大，我觉得虽然 FOUR 不是一款阅读类的 app ，但字体对于用户的体验终究是至关重要的。 不过遗憾的是我对中文字体的理解没有那么深刻，更别说去合理的搭配字体来营造一种十分惬意的感觉，所以我在 FOUR 上并没有对中文字体进行任何的优化和设计。 不过值得高兴的是，由于我平时对各类英文字体有过些许研究，加上自己也会写写画画，所以在制作 FOUR 的时候，我尝试着用 MartinRGB 的思维方式为 FOUR 设计一套合适的字体组合。 以下是我在总结前人经验的基础上，挑选出的几套比较优秀的字体搭配组合，同时我也将网上使用这种字体组合的应用场景找了出来，以便大家直观的感受。简单的说明一下，下面的图片左边是对当前字号大小和字体细分种类的说明，图片右边的单词就是字体的名称哦。 Lato 是一个相对而言较新的字体，它在设计之初被广泛用于带有用户界面的网站设计，这主要是因为它给人一种坚固感和些许的中性风格。 Lato 这个词出自波兰语，关于它的解释呢，我觉得还是用英文原文来做解释比较好，这样能不破坏它的语义。 Lato means “Summer” in Polish. “Male and female, serious but friendly. With the feeling of the Summer,”– Łukasz Dziedzic, Lato creator. 这个无衬线的字体组合是根据传统的广告字体进化而来，它能够很快的抓住用户的注意力，尤其是它的一级字体和二级字体造成了很好的视觉对比效果。 Kollektif 字体诞生的目的就是为了打破几何字体精致清新的风格，这种字体的视觉冲击感主要在于它的圆形设计和强烈的设计感。而 Gidole 字体是一种细而简明的字体，这与 Kollektif 的沉重感形成了一种很好的互补效果。 Six Caps 是一种非常紧凑且窄瘦的字体，非常适合用于做标题。与 Archivo Narrow 搭配后能够营造出一种60年代的复古风。加上三级字体采用了 Source Sans Pro 后，三种风格迥异的字体能够很好的表达或者从某种程度上暗示出消息的重要性和顺序性。 Raleway 和 Roboto Condensed 的组合在很多海报中都被使用过，这是一个非常非常经典的搭配，由它们构成的主副标题会给人十分深刻的印象。 Bebas Neue 在时尚领域里非常讨好，它简明干净的形式使它具有成为一个好标题的所有基本条件，它自身具有很漂亮圆角设计感，同时相比于其他字体来说，它是一个偏瘦的字体，如果有一个相比它而言较为矮胖的字体就会是一个完美的搭配，刚好 Montserrat 就是这样一个非常好的搭配角色。 Norwester 是一个非常引人注目的字体，非常适合做标题，当 Norwester 与 Kollektif ，还有 Montserrat 组合在一起能够产生一种极其强烈的几何效果感觉，这也是我非常非常喜欢的一个字体组合。 Roboto Condensed 是 Sans serif 系列的衍生体，十分适合阅读，它被广泛引用在科技领域的文字设计中。相比于它的父类，它在高度上的变化使得它给人一种更加强烈的凝聚感。 对这8种字体组合做完分析后，我认为字体组合1给我的感觉与 FOUR 的气质十分契合，不求轰轰烈烈，只求天长地久， Lato 字体的踏实稳重感正是 FOUR 需要的，所以就选它了！ FOUR的实现回顾 FOUR 的整个制作过程，如果从技术角度来看它的话，其实它并没有什么特别的技术难点。 在设计模式上，选用了最常见的 MVC 模式。 在数据库上，我使用了移动端的新贵- Realm ，原因很简单： Realm 真的好用到哭，有没有！！！ 在动画上，用 JazzHands 框架实现了引导页上的动画效果，用 pop 框架实现了其余部分的动画效果。 在 UI 界面上，咳咳咳，请允许我吐槽一下！但凡在 Github 搜到的那些精致漂亮的 UI 框架都是用 Swift 编写的，为毛就没有人用 OC 写呢！！！哎，好吧，自己从头搭建吧…. 仔细琢磨下，唯一值得分享的就是 Analysis 界面的实现，首先用一个动图来展示下它的效果吧。 这个界面看起来十分简单，但它能展现的内容却十分丰富： 首先它包含每个任务在近一周内的执行时间趋势图。 其次在触摸和滑动曲线的过程中，下端的界面可以弹出任务在某一天内执行的时间长度。 最后在相同的界面中，可以展现出多个任务的曲线走势图。 它的实现主要还是基于 JBChartView 的 Demo 而想到的。所以如果大家有兴趣，可以直接阅读该框架的Demo文件，我想一定会有不小的收获，如果你觉得看起来麻烦，也可以看看 FOUR 的源代码。 FOUR 的诞生经过大概 3 周左右的时间，我终于将 FOUR 从一个模糊的概念变成了一个具体的 app ，虽然它还存在着各种各样的缺点，但对于我这样一个半年前还从来未接触过编程的人而言，那种强烈的成就感是不言而喻的。 我到现在还记得当时大概是下午 2 点多提交的 app ，之后我就以每隔半小时的速度刷一遍邮箱，期待着 Apple 的回复。直到凌晨 3 点多，我终于收到审核通过的邮件，那一刻的心情，觉得比当年考上大学还要激动，弄得我后半夜都没睡着。 Anyway ，终于实现了自己在 2015 年给自己许下的心愿。 虽然 FOUR 的上架对于我来说是近期工作的一个终点，但从长远来看，这或许才是我在 iOS 开发道路上真正意义上的一个起点。 因此，在 app 上架后，我就将其在 GitHub 上开源了，一方面是希望通过它来记录自己的技术成长，一方面也是希望以后能够有机会和更多优秀的人共同工作，共同成长。至于未来，我希望能像前面说的一样，逐步完成 FOUR 的 swift 版本， React-Native 版本， React-Cocoa 版本等等。 下面是 FOUR 在 Github 和 App Store 上的地址： GitHub ： https://github.com/SketchK/FOURApp Store ： https://itunes.apple.com/app/id1136588862 如果您喜欢 FOUR ，记得给我点个星星哦！ 如果对项目任何问题，欢迎在项目主页上提 issue 。 当然 FOUR 里还有个功能就 Donate ，如果各位觉得不错，可以考虑赞助我个可乐神马的！: ]哈哈哈，在此先谢谢各位啦！ 尾声这篇文章基本就要结束了，可能也没什么干货，就是说了说我在制作 FOUR 时都想了什么，做了什么，干了什么。 如果非要说说这篇文章的意义所在，我想应该是： 我希望通过这篇文章,能够激励更多的人以一种踏踏实实的方式去追寻他们内心向往的东西。 PS：说这些是因为在加入的这些个 iOS 开发者微信群里，总能听到行业内的人说今天面试了几个伪造简历的年轻人，或者说某某培训机构教学生包装假简历。 我很难想像现在的 iOS 就业市场中，还能有多少比我这样一个已经快要 30 岁，无相关行业经历，无相关专业背景，完全零基础，天资平平的人条件还要差。 在这里我并不想说谁好谁不好，谁对谁不对，我只是觉得踏踏实实的去走自己的路或许能收获更多，至少会多一份自信，少一份不安。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[resizableImageWithCapInsets:方法的探析]]></title>
      <url>%2F2015%2F07%2F30%2FThe-Detail-Of-ResizableImageWithCapInsets-Method%2F</url>
      <content type="text"><![CDATA[让我们深入分析下 resizableImageWithCapInsets: 方法 故事背景苹果公司为iOS开发者提供了以下的方法用于处理图片的拉伸问题 12- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets resizingMode:(UIImageResizingMode)resizingMode//为行文方便,之后简称该方法为拉伸方法 但在实际使用过程中,我发现自己对该方法的理解不够深入,所以今天特地编写了一些代码来探析该方法!好了,废话不多说,下面我们就开始探析该方法的奥妙吧! ##方法介绍和说明 12345678910- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets resizingMode:(UIImageResizingMode)resizingMode//该方法返回的是UIImage类型的对象,即返回经该方法拉伸后的图像//传入的第一个参数capInsets是UIEdgeInsets类型的数据,即原始图像要被保护的区域//这个参数是一个结构体,定义如下//typedef struct &#123; CGFloat top, left , bottom, right ; &#125; UIEdgeInsets;//该参数的意思是被保护的区域到原始图像外轮廓的上部,左部,底部,右部的直线距离,参考图2.1//传入的第二个参数resizingMode是UIImageResizingMode类似的数据,即图像拉伸时选用的拉伸模式,//这个参数是一个枚举类型,有以下两种方式//UIImageResizingModeTile, 平铺 //UIImageResizingModeStretch, 拉伸 设计实验方法###实验对象 Image对象尺寸为60*128(为行文方便,之后简称为原始图像,图3.1) ImageView对象尺寸为180*384(为行文方便,之后简称为相框) ###实验方法 对原始图像使用拉伸方法并输入不同的参数 将拉伸后的图像放入相框,观察其拉伸效果 ###测试软件的界面设计界面设计如图3.2 正上方为原始图像窗口,用于显示原始图像的效果 左下方为测试图像窗口,用于显示测试状况的效果 右下方为对比图像窗口,用于显示默认状况的效果 实验分析拉伸模式resizingMode参数为UIImageResizingModeStretch capInsets参数为UIEdgeInsetsMake(0, 0, 0, 0)时当我们向拉伸方法传入该组参数时,代表我们未对原始图像的任何区域进行保护.其拉伸效果如图4.1.1在该种情况下,我们发现原始图像按比例放大了3倍,因此我们将该情况当做拉伸模式下的默认状况 在之后的实验中,我们将该种状况当做参考对象,显示在界面的右下角 capInsets参数为UIEdgeInsetsMake(42, 0, 0, 0)时当我们向拉伸方法传入该组参数时,代表我们对原始图像上部的三分之一进行保护(即红色方块区域).其拉伸效果如图4.1.2 在该种情况下,我们可以发现拉伸后的图像中: 原始图像中受保护的区域(即红色方块区域)在Y轴方向保持了原比例,但在X轴方向进行了拉伸 原始图像中未受保护的区域,直接按比例进行了拉伸 capInsets参数为UIEdgeInsetsMake(0,20, 0, 0)时当我们向拉伸方法传入该组参数时,代表我们对原始图像左部的三分之一进行保护(即红色方块区域).其拉伸效果如图4.1.3 在该种情况下,我们可以发现拉伸后的图像中: 原始图像中受保护的区域(即红色方块区域)在X轴方向保持了原比例,但在Y轴方向进行了拉伸 原始图像中未受保护的区域,直接按比例进行了拉伸 capInsets参数为UIEdgeInsetsMake(42, 20, 42, 20)时当我们向拉伸方法传入该组参数时,代表我们对原始图像除数字5以外的区域进行保护(即两个红色方块围起来的区域).其拉伸效果如图4.1.4 在该种情况下,我们可以发现拉伸后的图像中: 在X轴上,由于1被左边和上边的设置保护,3被右边和上边的设置保护,所以只能用中间的2来拉伸,同理最底下的7,8,9 在Y轴上,由于1被左边和上边的设置保护,7被左边和下边的设置保护,所以只能用中间的4来拉伸,同理最底下的3,6,9 由于5没有被保护,所以在整个剩余的空间中,用5进行拉伸填充 选择平铺模式resizingMode参数为UIImageResizingModeTile capInsets参数为UIEdgeInsetsMake(0, 0, 0, 0)时当我们向拉伸方法传入该组参数时,代表我们未对原始图像的任何区域进行保护.其平铺效果如图4.2.1 在该种情况下,我们发现原始图像按比例填充了相框,因此我们将该情况当做拉伸模式下的默认状况 在之后的实验中,我们将该种状况当做参考对象,显示在界面的右下角 capInsets参数为UIEdgeInsetsMake(42, 0, 0, 0)时当我们向拉伸方法传入该组参数时,代表我们对原始图像上部的三分之一进行保护(即红色方块区域).其平铺效果如图4.2.2 在该种情况下,我们可以发现拉伸后的图像中: 原始图像中受保护的区域(即红色方块区域)在Y轴方向保持了原比例,但在X轴方向进行了平铺填充 原始图像中未受保护的区域,直接按比例进行了平铺,但不包含被保护的区域(注意观察蓝色箭头所指的区域) capInsets参数为UIEdgeInsetsMake(0,20, 0, 0)时当我们向拉伸方法传入该组参数时,代表我们对原始图像左部的三分之一进行保护(即红色方块区域).其平铺效果如图4.2.3 在该种情况下,我们可以发现拉伸后的图像中: 原始图像中受保护的区域(即红色方块区域)在X轴方向保持了原比例,但在Y轴方向进行了平铺填充 原始图像中未受保护的区域,直接按比例进行了平铺,但不包含被保护的区域(注意观察蓝色箭头所指的区域) capInsets参数为UIEdgeInsetsMake(42, 20, 42, 20)时当我们向拉伸方法传入该组参数时,代表我们对原始图像除数字5以外的区域进行保护(即两个红色方块围起来的区域).其拉伸效果如图4.2.4 在该种情况下,我们可以发现拉伸后的图像中: 在X轴上,由于1被左边和上边的设置保护,3被右边和上边的设置保护,所以只能用中间的2来平铺,同理最底下的7,8,9 在Y轴上,由于1被左边和上边的设置保护,7被左边和下边的设置保护,所以只能用中间的4来平铺,同理最底下的3,6,9 由于5没有被保护,所以在整个剩余的空间中,用5进行平铺填充 结论和建议通过8组实验数据可以观察出拉伸方法在平铺模式和拉伸模式下的变化过程和主要区别,由此我们可知: 对原始图形使用拉伸方法且在四周增加保护区域后,能保证原始图形的四个角不失真,但其余部分的变化细节则有不同 如果原始图像的外轮廓不平整的话,使用拉伸方式会让外轮廓的不平整度放大,使用平铺方式应该能减小这种情况 附录-代码为了缩短代码的长度,我使用了Storyboard搭建软件界面,想重现实验的朋友可以自行构建界面,具体的参数我在文章和附录中进行了简要说明,我相信聪明的你一定可以搞定! 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#import "ViewController.h"@interface ViewController ()@property (weak, nonatomic) IBOutlet UIImageView *imageView1;@property (weak, nonatomic) IBOutlet UIImageView *imageView2;@property (weak, nonatomic) IBOutlet UIImageView *imageView3;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad];//--imageView1的相关内容------------------------------------------------------------------------------------ //相框大小为60 * 128 图片尺寸为60 * 128 //读取图片 UIImage *testImage1 = [UIImage imageNamed:@"123456789"]; testImage1 = [testImage1 resizableImageWithCapInsets:UIEdgeInsetsMake(0, 0, 0, 0) resizingMode:UIImageResizingModeStretch]; self.imageView1.image = testImage1; //---imageView2的相关内容----------------------------------------------------------------------------------- //相框为180 * 384 图片尺寸为60 * 128 相框大小为原始图片的3倍 //读取图片 UIImage *testImage2 = [UIImage imageNamed:@"123456789"]; /***********************************************/ //方法1 resizableImageWithCapInsets:默认是平铺 //方法2 resizableImageWithCapInsets: resizingMode: 方法 // UIImageResizingModeTile, 平铺 //平铺的概念是保证原图像大小不变,将新图像填充满 //testImage2 = [testImage2 resizableImageWithCapInsets:UIEdgeInsetsMake(0, 0, 0, 0) resizingMode:UIImageResizingModeTile]; //将上部的三分之一"保护",然后进行显示 //这代表新图像中,上部的三分之一和原图像一样,而其余部分的填充不会使用原图像上部的三分之一 // testImage2 = [testImage2 resizableImageWithCapInsets:UIEdgeInsetsMake(42, 0, 0, 0) resizingMode:UIImageResizingModeTile]; //将左部的三分之一"保护",然后进行显示 //这代表新图像中,上部的三分之一和原图像一样,而其余部分的填充不会使用原图像上部的三分之一 // testImage2 = [testImage2 resizableImageWithCapInsets:UIEdgeInsetsMake(0,20, 0, 0) resizingMode:UIImageResizingModeTile]; //将四周进行保护后 //在X轴上,由于1被左边的设置保护,3被右边的设置保护,所以中间只能用2来平铺,同理,7和9之间的8 //在Y轴上,由于1被上边的设置保护,7被下边的设置保护,所以中间只能用4来平铺,同理,3和9之间的6 //由于5没有被保护,所以在整个空间中,用5进行平铺来填充剩余的区域 // testImage2 = [testImage2 resizableImageWithCapInsets:UIEdgeInsetsMake(42, 20, 42, 20) resizingMode:UIImageResizingModeTile]; /***********************************************/ //resizableImageWithCapInsets: resizingMode: 方法 // UIImageResizingModeStretch, 拉伸 // 拉伸的概念是直接按比例将图片放大到与相框尺寸相同的图像, //testImage2 = [testImage2 resizableImageWithCapInsets:UIEdgeInsetsMake(0, 0, 0, 0) resizingMode:UIImageResizingModeStretch]; //将上部的三分之一"保护",然后进行显示 //保证原图像上部的三分之一在Y轴上不被拉伸,其余部分按剩余比例拉伸 //testImage2 = [testImage2 resizableImageWithCapInsets:UIEdgeInsetsMake(42, 0, 0, 0) resizingMode:UIImageResizingModeStretch]; //将左部的三分之一"保护",然后进行显示 //保证原图像左部的三分之一在Y轴上不被拉伸,其余部分按剩余比例拉伸 //testImage2 = [testImage2 resizableImageWithCapInsets:UIEdgeInsetsMake(0, 20, 0, 0) resizingMode:UIImageResizingModeStretch]; //将四周进行保护后 //在X轴上,由于1被左边的设置保护,3被右边的设置保护,所以中间只能用2来拉伸,同理,7和9之间的8 //在Y轴上,由于1被上边的设置保护,7被下边的设置保护,所以中间只能用4来拉伸,同理,3和9之间的6 //由于5没有被保护,所以在整个空间中,用5进行拉伸来填充剩余的区域 //testImage2 = [testImage2 resizableImageWithCapInsets:UIEdgeInsetsMake(42, 20, 42, 20) resizingMode:UIImageResizingModeStretch]; //将图片添加到相框 self.imageView2.image = testImage2; //-----imageView3的相关内容---------------------------------------------------------------------------------- //读取图片 UIImage *testImage3 = [UIImage imageNamed:@"123456789"]; /***********************************************/ //resizableImageWithCapInsets默认是平铺 //resizableImageWithCapInsets默认情况对比图 //testImage3 = [testImage3 resizableImageWithCapInsets:UIEdgeInsetsMake(0, 0, 0, 0) resizingMode:UIImageResizingModeTile]; /***********************************************/ //resizableImageWithCapInsets: resizingMode: 方法 // UIImageResizingModeTile, 平铺 (已经测试过了,) // UIImageResizingModeStretch, 拉伸 //testImage3 = [testImage3 resizableImageWithCapInsets:UIEdgeInsetsMake(0, 0, 0, 0) resizingMode:UIImageResizingModeStretch]; /***********************************************/ //将图片添加到相框 self.imageView3.image = testImage3; // Do any additional setup after loading the view, typically from a nib.&#125;@end]]></content>
    </entry>

    
  
  
</search>
